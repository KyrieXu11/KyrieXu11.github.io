# 并查集

两个集合找祖宗节点，看祖宗是否相等，如果祖宗相同，则认为这两个集合相同。





# 滑动窗口

例题：给定一个数组arr和一个窗口，这个窗口在运动，求在这个窗口每次运动时，这个窗口的最大值。

解题思路：

维护一个双端队列，保持单调性，从大到小。

每次窗口移动时，如果是right指针移动，则把arr[right]给放入队列中，如果队列中有比arr[right]小的就pop。

如果left指针移动，看队首是否存放的left所在的下标。

```java
	public static int[] getMaxValInWindow(int[] arr, int w) {
        if (arr == null || arr.length < w) {
            return null;
        }
        // 从小->大
        Deque<Integer> deque = new ArrayDeque<>();
        int[] res = new int[arr.length - w + 1];
        int idx = 0;

        // right = i
        for (int i = 0; i < arr.length; i++) {

            while (!deque.isEmpty() && arr[deque.peekLast()] <= arr[i]) {
                deque.pollLast();
            }
            deque.addLast(i);
            if (deque.peekFirst() == i - w) {
                deque.pollFirst();
            }
            // 如果right >= 窗口长度了，就要统计最大值了
            if (i >= w - 1) {
                res[idx++] = arr[deque.peekFirst()];
            }
        }
        return res;
    }
```



# 单调队列

例题：给定一个滑动窗口和一个数组，每次滑动窗口都往右边移动1格，求每个滑动窗口中的最大值。leetcode：[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

解法：

维护一个单调队列，右指针在移动的时候，把元素的下标从后面入队，此时要维护单调性，如果当前元素下标入队会破坏单调性，则一直pop数据，直到单调性正确为止。

每次左边指针移动时，如果左边指针的下标是队首中的元素，则将队首的元素过期（pop()）掉，每次窗口移动时，都取队首元素作为当前窗口的最大值。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int w) {
        int n = nums.length;
        int idx = 0;
        // 比nums的长度少w-1个
        int[] res = new int[n - w + 1];
        Deque<Integer> queue = new ArrayDeque<>();
        for(int r = 0; r < n; r++) {
            // r在移动时，维持单调队列的单调性
            while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[r]) {
                queue.pollLast();
            }

            queue.addLast(r);
            // 滑动窗口的左边界
            int l = r - w + 1;
            // 如果滑动窗口把队列的最大值给划过去了，就需要把队首元素给删除
            if (queue.peekFirst() == l - 1) {
                queue.pollFirst();
            }

            // 如果有滑动窗口了，就要取最大值了
            if (l >= 0) {
                res[idx++] = nums[queue.peekFirst()];
            }
        }

        return res;
    }
}
```



# 单调栈

例题：给定一个数组arr，求数组中每个元素的左边和右边的离该数字最近的最大的数。

解法：

维护一个栈，在遍历数组的时候，把数放进栈里面，不过要保证单调性。

```java
	public static int[][] getNearBiggerNoRepeat(int[] arr) {
        int[][] res = new int[arr.length][2];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < arr.length; i++) {
            // 如果栈里面的数比当前数要大，则需要pop栈中数据，把当前数据放入stack。
            while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {
                int popIndex = stack.pop();
                int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
                if (leftLessIndex != -1) {
                    res[popIndex][0] = arr[leftLessIndex];
                } else {
                    res[popIndex][0] = leftLessIndex;
                }
                res[popIndex][1] = arr[i];
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int popIndex = stack.pop();
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
            if (leftLessIndex != -1) {
                res[popIndex][0] = arr[leftLessIndex];
            } else {
                res[popIndex][0] = leftLessIndex;
            }
            res[popIndex][1] = -1;
        }
        return res;
    }
```



# 题目

## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

解法：

枚举每一个字字符串，看是否为回文串，如果为回文串，并且长度更长，则更新结果。

判断是否为回文串，用dp记录一下[i....j]是否已经计算过，如果计算过则返回，否则`f(i, j) = s[i] == s[j] && f(i + 1, j -1);`

```java
	public String longestPalindrome(String s) {
        int n = s.length();
        String res = "";
        Boolean[][] dp = new Boolean[n + 1][n + 1];

        for(int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (isPalindrome(dp, s, i, j) && j - i + 1 > res.length()) {
                    res = s.substring(i, j + 1);
                }
            }
        }
        return res;
    }

    public boolean isPalindrome(Boolean[][] dp, String s, int i, int j) {

        if (dp[i][j] != null) {
            return dp[i][j];
        }

        if (i == j) {
            dp[i][j] = true;
        } else if (i + 1 == j) {
            dp[i][j] = s.charAt(i) == s.charAt(j);
        } else {
            dp[i][j] = (s.charAt(i) == s.charAt(j) && isPalindrome(dp, s, i + 1, j - 1));
        }

        return dp[i][j];
    }
```

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

解法：

使用滑动窗口，用哈希表来存放不同元素的最大的下标。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 左边界
        int l = 0;
        int n = s.length();
        int res = 0;
        Map<Character, Integer> window = new HashMap<>();
        for(int r = 0; r < n; r++) {
            // 如果包含了当前字符，说明有重复字符，需要移动左边界。
            if (window.containsKey(s.charAt(r))) {
                // 这里使用max的原因是：如果不使用，则在abba 的这种情况下，在r指针指向最后一个a的时候，l会往回挪。
                l = Math.max(l, window.get(s.charAt(r)) + 1);
            }
            window.put(s.charAt(r), r);
            res = Math.max(res, r - l + 1);
        }
        return res;
    }
}
```

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

解法：

求i-j的的面积，有三种情况

1. i-j就是最大的
2. i+1,j中会有最大的
3. i,j - 1中会有最大的

优化前的：

```java
class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int[][] dp = new int[n][n];
        for(int[] d: dp) {
            Arrays.fill(d, -1);
        }
        return f(dp, height, 0, n - 1);
    }

    // i 和 j之间的最大面积
    public int f(int[][] dp, int[] height, int i, int j) {
        if(dp[i][j] != -1) {
            return  dp[i][j];
        }

        // base case: j - i == 1 return min(height[i], height[j])
        if (j - i == 1) {
            dp[i][j] = Math.min(height[i], height[j]);
            return dp[i][j];
        }
        int s = (j - i) * Math.min(height[i], height[j]);
        dp[i][j] = Math.max(s, Math.max( f(dp, height, i + 1, j), f(dp, height, i, j - 1)));
        return dp[i][j];
    }
}
```





优化后的

```java
class Solution {
    public int maxArea(int[] height) {
        return f(height, 0, height.length - 1);
    }

    // i 和 j之间的最大面积
    public int f(int[] height, int i, int j) {
        // base case: j - i == 1 return min(height[i], height[j])
        if (j - i == 1) {
            return Math.min(height[i], height[j]);
        }
        int tmp;
        // 因为面积是按照最矮的一条边来算的，s=x*h. 面积是无论如何都不会超过h*x的，x为最短边，但是如果移动高的则可能会变得更小。
        if (height[i] < height[j]) {
            tmp = f(height, i + 1, j);
        } else {
            tmp = f(height, i, j - 1);
        }

        int s = (j - i) * Math.min(height[i], height[j]);
        return Math.max(s, tmp);
    }
}
```

## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

解法：

维护一个单调栈，每次要破坏单调性的时候，计算接到的雨水。

在栈中，栈底的元素总是比栈顶要大（或者等于）的，所以当要破坏单调性的时候，就说明出现了凹槽。

在重新维护单调栈的时候，先把栈顶元素出栈，原来栈顶下面的元素为left，此时待入栈的元素height[i]，和left的长度就是 i - left - 1 (-1是要减掉height[i]本身的厚度)。

计算雨水的时候，高即为left和height[i]的最小值-刚出栈的元素的高度。

```java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        for(int i = 0; i < height.length; i++) {
            // 遇到破坏单调性的元素，重新入栈了，此时应该计算能接到的水的数量
            while(!stack.isEmpty() && height[stack.peek()] < height[i]) {
                int top = stack.pop();
                // 栈中至少要有两个元素
                if(stack.isEmpty()) {
                    break;
                }
                int left = stack.peek();
                int curLen = i - left - 1;
                // 每次都是计算top被夹住的情况
                int curHeight = Math.min(height[i], height[left]) - height[top];

                res += curHeight * curLen;

            }
            stack.push(i);
        }

        return res;
    }
}
```

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

同[11. 盛最多水的容器](#11. 盛最多水的容器)，使用记忆化搜索。

可以一步一步的优化成自底向上的dp。优化就是使用镜像的方式，原本的base case，是m和n那个边界返回的1，如果需要改成自底向上的话则需要对称的修改。

```java
class Solution {
    // 版本3
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[n][m];
        for(int i = 0; i < m; i++ ) {
            dp[0][i] = 1;
        }

        for(int i = 0; i < n; i++) {
            dp[i][0] = 1;
        }

        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[n - 1][m - 1];
    }
    
	// 版本2
    // public int uniquePaths(int m, int n) {
    //     int[][] dp = new int[n + 2][m + 2];
    //     for(int[] d: dp) {
    //         Arrays.fill(d, -1);
    //     }

    //     return dfs(dp, m, n, 1, 1);
    // }

    // public int dfs(int[][] dp,int m, int n, int x, int y) {
    //     if(dp[x][y] != -1) {
    //         return dp[x][y];
    //     }

    //     if (x > n || y > m) {
    //         dp[x][y] = 0;
    //     } else if (x == n && y == m) {
    //         dp[x][y] = 1;
    //     } else {
    //         dp[x][y] = dfs(dp, m, n, x + 1, y) + dfs(dp, m, n, x, y + 1);
    //     }

    //     return dp[x][y]; 
    // }
    
    // 版本1
	// public int uniquePaths(int m, int n) {
    //     return dfs(m, n, 1, 1);
    // }
    //
    // public int dfs(int m, int n, int x, int y) {
    //     if (x > n || y > m) {
    //         return 0;
    //     } else if (x == n && y == m) {
    //         return 1;
    //     }
    //
    //     return dfs(m, n, x + 1, y) + dfs(m, n, x, y + 1);
    // }
}
```

## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)



## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

经典的dp问题，用二维的dp数组存放。

```java
class Solution {
    private int[][] dp;
    public int coinChange(int[] coins, int amount) {
        dp = new int[amount + 1][coins.length + 1];
        for(int[] d: dp) {
            Arrays.fill(d, -2);
        }
        return coinChange(coins, amount, 0, 0);
    }

    public int coinChange(int[] coins, int amount, int sum, int index) {
        if (sum > amount || index >= coins.length || sum < 0) {
            return -1;
        }

        if(dp[sum][index] != -2) {
            return dp[sum][index];
        }
		
        // 这里返回0是表示basecase，需要退出了，如果是在求零钱兑换的方式，这里返回1表示一种兑换方式，但是在这里是求硬币个数
        // 所以不能在这里返回1，需要在调用递归函数的时候计算。
        if (sum == amount) {
            dp[sum][index] = 0;
        } else {
            // 选择当前的硬币，并且可以再次选择相同的硬币，所以p1需要+1
            int p1 = coinChange(coins, amount, sum + coins[index], index);
            // 不选当前硬币，选择新的硬币
            int p2 = coinChange(coins, amount, sum, index + 1);
            if (p1 == -1 && p2 == -1) {
                dp[sum][index] = -1;
            } else if (p1 == -1) {
                dp[sum][index] = p2;
            }else if(p2 == -1) {
                dp[sum][index] = p1 + 1;
            }else {
                dp[sum][index] = Math.min(p1 + 1, p2);
            }
        }
        return dp[sum][index];
    } 
}
```

