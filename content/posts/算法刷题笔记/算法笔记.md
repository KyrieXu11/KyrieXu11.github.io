# 基础算法

## 快速排序

背模板，避免边界问题出现。

快速排序的算法思想是（从小到大排序）：

1. 选定一个哨兵元素，从左往右扫描，直到找到第一个比这个数大的数之后，从右往左扫描，直到找到第一个比这个数要小的数。
2. 如果左边的指针小于右边的指针，交换两个指针指向的数。 
3. 重复上面的步骤，直到左边的指针大于右边的指针。

```java
    public static void quickSort(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }

        // 由于选取的第一个数为哨兵节点，所以i = l - 1，为了统一，j也写成r + 1
        int x = nums[l], i = l - 1, j = r + 1;
        while (i < j) {
            while (nums[++i] < x) ;
            while (nums[--j] > x) ;
            // 从i出发找到比x大的数，从j出发找到比x小的数，交换
            if (i < j) {
                swap(nums, i, j);
            }
        }

        // 注意边界
        quickSort(nums, l, j);
        quickSort(nums, j + 1, r);
    }

    private static void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
```

### 快速选择

```java
    public static int quickSelect(int[] nums, int k, int l, int r) {
        if (l >= r) {
            return nums[l];
        }
        int x = nums[l], i = l - 1, j = r + 1;
        while (i < j) {
            while (nums[++i] < x) ;
            while (nums[--j] > x) ;
            if (i < j) {
                swap(nums, i, j);
            }
        }
        // 如果k落在分区的左边，则就是找左边分区第k小的数字
        if (j - l + 1 >= k) {
            return quickSelect(nums, k, l, j);
        }
        // 如果落在了右边的分区，则找右边分区第 k - (j - l + 1) 小的数字
        return quickSelect(nums, k - (j - l + 1), j + 1, r);
    }
```

## 归并排序

和快速排序一样，背模板，避免造成边界问题。
算法思想是：
1. 把一个大数组不断分成小数组。
2. 从小数组开始，选取两个小数组，合并数组。
3. 重复上述步骤，直到只有一个数组。

```java
    public static void mergeSort(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
    }

    public static void mergeSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }
        int mid = l + r >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        merge(nums, l, r);
    }

    private static void merge(int[] nums, int l, int r) {
        int[] tmp = new int[r - l + 1];
        int mid = l + r >> 1;
        int i = l, j = mid + 1, idx = 0;

        while (i <= mid && j <= r) {
            tmp[idx++] = nums[i] < nums[j] ? nums[i++] : nums[j++];
        }
        while (i <= mid) {
            tmp[idx++] = nums[i++];
        }
        while (j <= r) {
            tmp[idx++] = nums[j++];
        }
        for (int k = 0; k < tmp.length; k++) {
            nums[l + k] = tmp[k];
        }
    }
```

### [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

在归并排序中，分成了两个数组，其中会产生三种情况：

1. 所有的逆序对都在同一边（左边和右边）。
2. 逆序对分别在两个部分，

其中第一个问题，可以递归的转换成第二个问题，所以只需要关心第二个问题。

在归并的时候，两边的数组都是有序的，所以对于前面部分的 `i`和后面部分的`j`来说，如果`nums[i] > nums[j]`，即前面的部分>后面的部分时，`nums[i]`和`nums[j]`都组成了一对逆序对。并且，由于两边的部分都是有序的，所以对于下标`j`来说，左边部分的下标大于`i`的元素都能与下标为`j`的元素组成逆序对。

总结一下来说，对于j来说，逆序对数为`mid - i + 1`，而对于右边部分的所有元素来说都可能会出现这种情况。所以求和就行。

![逆序对数](基础算法/归并排序/逆序对数.jpg)

```java
class Solution {
    public int reversePairs(int[] nums) {
        return mergeSort(nums, 0, nums.length - 1);
    }

    public int mergeSort(int[] nums, int l, int r) {
        if (l >= r) {
            return 0;
        }
        int mid = l + r >> 1;
        
        int res = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r);

        int[] tmp = new int[r - l + 1];
        // 归并
        int i = l , j = mid + 1, idx = 0;
        while(i <= mid && j <= r) {
            // 前面的小于后面的，则正常归并，否则计算逆序对数
            if (nums[i] <= nums[j]) {
                tmp[idx++] = nums[i++];
            } else {
                tmp[idx++] = nums[j++];
                res += mid - i + 1;
            }
        }
        while(i <= mid) {
            tmp[idx++] = nums[i++];
        }
        while(j <= r) {
            tmp[idx++] = nums[j++];
        }

        for(int k = 0; k < tmp.length; k++) {
            nums[l + k] = tmp[k];
        }
        return res;
    }
}
```

# KMP算法

![1](kmp/1.png)

# 并查集

两个集合找祖宗节点，看祖宗是否相等，如果祖宗相同，则认为这两个集合相同。

# 前缀树

# 堆

![1](堆/1.png)

使用数组来表示堆，有下面的几个要点：

1. 堆实际的逻辑结构为完全二叉树，即除了叶子节点之外，每个节点要么满要么空。
2. 如果是小顶堆，则每个子树父节点的值必须大于所有子节点的值。
3. 底层存储结构为数组时，假设父节点的下标为`x`（必须从1开始算），则左子树的位置为`2x`，右子树的位置为`2x+1`。
4. 上图的down和up操作分别是，让节点往下沉和往上挪的操作。在插入或者删除节点的时候，可能会导致堆的平衡性被破坏，所以需要有平衡的过程。

```java
    public static class Heap {
        private final static int N = 10;
        private int[] h;
        // 指向了堆的最后一个元素
        private int size;

        public Heap(int[] h) {
            int n = h.length;
            this.h = new int[N];
            System.arraycopy(h, 0, this.h, 1, n);
            this.size = n - 1;
            for (int i = size / 2; i > 0; i--) {
                down(i);
            }
        }

        public Heap(int n) {
            // 下标从1开始，所以为 n + 1
            this.h = new int[n + 1];
            this.size = 0;
        }

        public void initFromArr(int[] h) {
            int n = h.length;
            this.size = n;
            for (int i = size / 2; i > 0; i--) {
                down(i);
            }
        }

        public void insert(int val) {
            if (size >= h.length) {
                return;
            }
            // 要先执行size=size+1，不然会覆盖有用的元素
            h[++size] = val;
            up(size);
        }

        private void down(int i) {
            // min是最小的节点的下标
            int min = i;
            // 如果左儿子比i小，则取左儿子
            if (i * 2 <= size && h[i * 2] < h[min]) {
                min = 2 * i;
            }
            // 如果右儿子比左儿子和i都要小，则取右儿子
            // min的含义就是取 左右儿子和当前节点 三个节点中的最小值
            if (i * 2 + 1 <= size && h[i * 2 + 1] < h[min]) {
                min = i * 2 + 1;
            }
            // 如果不是当前节点，说明左右儿子中必有一个比当前节点小
            if (min != i) {
                // 让小的元素往上走
                swap(h, min, i);
                // 大的元素继续往下沉
                down(min);
            }
        }

        private void up(int i) {
            // 父节点的下标都是 i/2
            // 如果 i 为左儿子节点，x = i/2
            // 如果 i 为右儿子节点，x = (i - 1)/2
            while (i / 2 > 0 && h[i / 2] > h[i]) {
                swap(h, i / 2, i);
                i /= 2;
            }
        }

        public int getSize() {
            return size;
        }

        public int getMin() {
            return h[1];
        }

        public void removeMin() {
            // 这里没有把size位置上的元素干掉
            // size指针已经不指向了原来的那个元素了，在插入的时候会直接覆盖原来的元素
            h[1] = h[size--];
            down(1);
        }

        public int popMin() {
            int res = getMin();
            removeMin();
            return res;
        }

        private static void swap(int[] nums, int i, int j) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }
```

# 滑动窗口

例题：给定一个数组arr和一个窗口，这个窗口在运动，求在这个窗口每次运动时，这个窗口的最大值。

解题思路：

维护一个双端队列，保持单调性，从大到小。

每次窗口移动时，如果是right指针移动，则把arr[right]给放入队列中，如果队列中有比arr[right]小的就pop。

如果left指针移动，看队首是否存放的left所在的下标。

```java
	public static int[] getMaxValInWindow(int[] arr, int w) {
        if (arr == null || arr.length < w) {
            return null;
        }
        // 从小->大
        Deque<Integer> deque = new ArrayDeque<>();
        int[] res = new int[arr.length - w + 1];
        int idx = 0;

        // right = i
        for (int i = 0; i < arr.length; i++) {

            while (!deque.isEmpty() && arr[deque.peekLast()] <= arr[i]) {
                deque.pollLast();
            }
            deque.addLast(i);
            if (deque.peekFirst() == i - w) {
                deque.pollFirst();
            }
            // 如果right >= 窗口长度了，就要统计最大值了
            if (i >= w - 1) {
                res[idx++] = arr[deque.peekFirst()];
            }
        }
        return res;
    }
```

# 动态规划

优化过程：

递归 -> 记忆化搜索 -> 画图 -> 自底向上的dp。

## 线性动态规划

### 背包问题

#### 01背包问题

对于有每个v都有选和不选两种选择，所以可以使用dfs来写。

但是**注意**！01背包问题，可能会出现**包未装满**的情况，所以需要看当前的下标是否超过了数组的长度，此时来判断包是否装满

<font color="red">**错误示例**</font>：

```java
	public static int dfs(int[] v, int[] w, int capacity, int cur, int curV) {
        // 在这里，没有考虑到，包未装满的情况
        if (curV > capacity || cur >= v.length) {
            return -1;
        }
        
        if (dp[cur][curV] != -2) {
            return dp[cur][curV];
        }
        
        if (curV == capacity) {
            dp[cur][curV] = 0;
        } else {
            int p1 = dfs(v, w, capacity, cur + 1, curV + v[cur]);
            int p2 = dfs(v, w, capacity, cur + 1, curV);
            if (p1 == -1){
                dp[cur][curV] = p2;
            } else if(p2 == -1) {
                dp[cur][curV] = p1 + w[cur];
            } else {
                dp[cur][curV] = Math.max(p1 + w[cur], p2);
            }
        }
        
        return dp[cur][curV];
    }
```

下面的才是<font color='green'>**正确示例**</font>：

```java
import java.util.*;

class Main{
    private static int[][] dp;
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] v = new int[n];
        int[] w = new int[n];
        
        dp = new int[n + 1][k + 1];
        
        for(int[] d : dp) {
            Arrays.fill(d, -2);
        }
        
        for(int i = 0; i < n; i++){
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        }
        System.out.println(dfs(v, w, k, 0, 0));
    }
    
    public static int dfs(int[] v, int[] w, int capacity, int cur, int curV) {
        // v: 6 5 5 2
        // w: 7 3 6 9
        // capacity: 10
        // 可能会出现包未装满的情况，但是此时的价值是最大的。
        if (cur >= v.length) {
            if (curV <= capacity) {
                dp[cur][curV] = 0;
                return 0;
            } else {
                return -1;
            }
        }
        if (curV > capacity) {
            return -1;
        }

        if (dp[cur][curV] != -2) {
            return dp[cur][curV];
        }

        if (curV == capacity) {
            dp[cur][curV] = 0;
        } else {
            int p1 = dfs(v, w, capacity, cur + 1, curV + v[cur]);
            int p2 = dfs(v, w, capacity, cur + 1, curV);
            if (p1 == -1 && p2 == -1) {
                dp[cur][curV] = -1;
            } else if (p1 == -1) {
                dp[cur][curV] = p2;
            } else if (p2 == -1) {
                dp[cur][curV] = p1 + w[cur];
            } else {
                dp[cur][curV] = Math.max(p1 + w[cur], p2);
            }
        }

        return dp[cur][curV];
    }
}
```

优化成dp表后的代码：

优化的步骤：先把base case位置上的数据填入表格，然后看递归函数的依赖关系。如上面的` p1`依赖于`dfs(cur+1, curV+v[cur])`的位置，所以优化成dp表的版本就是`dp[i][j] = max(dp[i + 1][j + v[i]] + w[i], ...)`，但是在优化时，需要注意边界问题。

```java
	public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String[] ns = br.readLine().split(" ");
        int n = Integer.parseInt(ns[0]);
        int V = Integer.parseInt(ns[1]);

        int[] v = new int[n];
        int[] w = new int[n];

        dp = new int[n + 1][V + 1];

        for (int i = 0; i < n; i++) {
            String[] tmp = br.readLine().split(" ");
            v[i] = Integer.parseInt(tmp[0]);
            w[i] = Integer.parseInt(tmp[1]);
        }
		
        // 在递归的base case中，n - 1 和 V 的位置都填0，所以可以忽略初始化的步骤。
        // 自顶向下的循环遍历，要求的就是dp[0][0]（在递归函数参数为0和0）
        for (int i = n - 1; i >= 0; i--) {
            for (int j = V; j >= 0; j--) {
                if (j + v[i] > V) {
                    dp[i][j] = dp[i + 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j + v[i]] + w[i], dp[i + 1][j]);
                }
            }
        }
        System.out.println(dp[0][0]);
    }
```

#### 01完全背包问题

与01背包问题不同的是，每件物品都是无限的。和下面的[322. 零钱兑换](#322-零钱兑换)是一个类型的。

```java
import java.util.*;

class Main{
    private static int[][] dp;
    public static void main(String[] args){
        // 省略输入过程
        
        dp = new int[n + 1][V + 1];
        
        for(int[] d : dp) {
            Arrays.fill(d, -2);
        }
        
        System.out.println(dfs(v, w, V, 0, 0));
    }
    
    public static int dfs(int[] v, int[] w, int capacity, int cur, int curV) {
        // v: 6 5 5 2
        // w: 7 3 6 9
        // capacity: 10
        // 可能会出现包未装满的情况，但是此时的价值是最大的。
        if (cur >= v.length) {
            if (curV <= capacity) {
                dp[cur][curV] = 0;
                return 0;
            } else {
                return -1;
            }
        }
        if (curV > capacity) {
            return -1;
        }

        if (dp[cur][curV] != -2) {
            return dp[cur][curV];
        }

        if (curV == capacity) {
            dp[cur][curV] = 0;
        } else {
            // 这个地方不能+1，要首先尝试一直拿一个物品。
            int p1 = dfs(v, w, capacity, cur, curV + v[cur]);
            int p2 = dfs(v, w, capacity, cur + 1, curV);
            if (p1 == -1 && p2 == -1) {
                dp[cur][curV] = -1;
            } else if (p1 == -1) {
                dp[cur][curV] = p2;
            } else if (p2 == -1) {
                dp[cur][curV] = p1 + w[cur];
            } else {
                dp[cur][curV] = Math.max(p1 + w[cur], p2);
            }
        }

        return dp[cur][curV];
    }
}
```

严格表结构优化的代码：

```java

```

#### 多重背包问题

<font size="50">这题切记！！</font>因为我太菜了，一开始做本题的时候，没有意识到是三维dp，如果使用<font color='red'>递归非循环</font>要使用<font color='red'>三维</font>dp表，如果使用<font color='blue'>递归循环</font>则二维就够了。这个是因为如果使用二维的状态表的话，会导致缓存错误命中。

举个例子：

下面的数据：

![1](背包问题/多重背包/1.png)

综上所述：

**需要添加一个额外的状态**，来表示当前的物品剩多少个。

<font color='red'>**错误**</font>答案 (截选核心代码片段):

```java
 	if (curV == V) {
            dp[cur][curV] = 0;
            return 0;
        }
        int res = 0;
        if (s[cur] > 0) {
            s[cur]--;
            int p1 = dfs(v, w, s, V, cur, curV + v[cur]);
            int p2 = dfs(v, w, s, V, cur + 1, curV);
            if (p1 == -1 && p2 == -1) {
                res = -1;
            } else if (p1 == -1) {
                res = p2;
            } else if (p2 == -1) {
                res = p1 + w[cur];
            } else {
                res = Math.max(p1 + w[cur], p2);
            }
            s[cur]++;
        } else {
            res = dfs(v, w, s, V, cur + 1, curV);
        }
        System.out.println(res);
        dp[cur][curV] = Math.max(res, dp[cur][curV]);
        return dp[cur][curV];
```

下面的才是<font color='green'>**正确**</font>的答案

```java
import java.util.*;

public class Main {
    private static int[][][] dp;

    public static void main(String[] args) {
        // 省略输入过程
        dp = new int[n + 1][V + 1][maxS + 1];
        for (int[][] d : dp) {
            for (int[] dd : d) {
                Arrays.fill(dd, -2);
            }
        }
        System.out.println(dfs(v, w, s, V, 0, 0));
    }


    public static int dfs(int[] v, int[] w, int[] s, int V, int cur, int curV) {
        if (cur >= v.length) {
            if (curV <= V) {
                return 0;
            } else {
                return -1;
            }
        }
        if (curV > V) {
            return -1;
        }

        if (dp[cur][curV][s[cur]] != -2) {
            return dp[cur][curV][s[cur]];
        }

        if (curV == V) {
            dp[cur][curV][s[cur]] = 0;
            return 0;
        }
        int res = 0;
        if (s[cur] > 0) {
            s[cur]--;
            int p1 = dfs(v, w, s, V, cur, curV + v[cur]);
            int p2 = dfs(v, w, s, V, cur + 1, curV);
            if (p1 == -1 && p2 == -1) {
                res = -1;
            } else if (p1 == -1) {
                res = p2;
            } else if (p2 == -1) {
                res = p1 + w[cur];
            } else {
                res = Math.max(p1 + w[cur], p2);
            }
            s[cur]++;
        } else {
            res = dfs(v, w, s, V, cur + 1, curV);
        }
        dp[cur][curV][s[cur]] = Math.max(res, dp[cur][curV][s[cur]]);
        return dp[cur][curV][s[cur]];
    }
}
```

也可以换成递归循环的方式：

```java
	public static int dfs(int[] v, int[] w, int[] s, int cur, int V) {
        if (cur >= v.length) {
            if (V >= 0) {
                dp[cur][V] = 0;
                return dp[cur][V];
            } else {
                return -1;
            }
        }

        if (V < 0) {
            return -1;
        }

        if (dp[cur][V] != -2) {
            return dp[cur][V];
        }

        if (V == 0) {
            dp[cur][V] = 0;
            return dp[cur][V];
        }

        int res = 0;
        for (int i = 0; i * v[cur] <= V && i <= s[cur]; i++) {
            int tmp = Math.max(dfs(v, w, s, cur + 1, V - i * v[cur]) + i * w[cur],
                    dfs(v, w, s, cur + 1, V));
            if (res < tmp) {
                res = tmp;
            }
        }
        dp[cur][V] = res;
        return dp[cur][V];
    }
```

## 动态规划压缩

# 单调队列

例题：给定一个滑动窗口和一个数组，每次滑动窗口都往右边移动1格，求每个滑动窗口中的最大值。leetcode：[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

解法：

维护一个单调队列，右指针在移动的时候，把元素的下标从后面入队，此时要维护单调性，如果当前元素下标入队会破坏单调性，则一直pop数据，直到单调性正确为止。

每次左边指针移动时，如果左边指针的下标是队首中的元素，则将队首的元素过期（pop()）掉，每次窗口移动时，都取队首元素作为当前窗口的最大值。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int w) {
        int n = nums.length;
        int idx = 0;
        // 比nums的长度少w-1个
        int[] res = new int[n - w + 1];
        Deque<Integer> queue = new ArrayDeque<>();
        for(int r = 0; r < n; r++) {
            // r在移动时，维持单调队列的单调性
            while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[r]) {
                queue.pollLast();
            }

            queue.addLast(r);
            // 滑动窗口的左边界
            int l = r - w + 1;
            // 如果滑动窗口把队列的最大值给划过去了，就需要把队首元素给删除
            if (queue.peekFirst() == l - 1) {
                queue.pollFirst();
            }

            // 如果有滑动窗口了，就要取最大值了
            if (l >= 0) {
                res[idx++] = nums[queue.peekFirst()];
            }
        }

        return res;
    }
}
```

# 单调栈

例题：给定一个数组arr，求数组中每个元素的左边和右边的离该数字最近的最大的数。

解法：

维护一个栈，在遍历数组的时候，把数放进栈里面，不过要保证单调性。

```java
	public static int[][] getNearBiggerNoRepeat(int[] arr) {
        int[][] res = new int[arr.length][2];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < arr.length; i++) {
            // 如果栈里面的数比当前数要大，则需要pop栈中数据，把当前数据放入stack。
            while (!stack.isEmpty() && arr[stack.peek()] < arr[i]) {
                int popIndex = stack.pop();
                int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
                if (leftLessIndex != -1) {
                    res[popIndex][0] = arr[leftLessIndex];
                } else {
                    res[popIndex][0] = leftLessIndex;
                }
                res[popIndex][1] = arr[i];
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int popIndex = stack.pop();
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
            if (leftLessIndex != -1) {
                res[popIndex][0] = arr[leftLessIndex];
            } else {
                res[popIndex][0] = leftLessIndex;
            }
            res[popIndex][1] = -1;
        }
        return res;
    }
```

# 差分数组

![1](差分数组和前缀和/1.png)

要修改在区间`[L...R]`内的数组中的所有的数，只需要让差分数组`d[L] + c` 以及 `d[R + 1] - c`即可。

## 例题

### [6158. 字母移位 II](https://leetcode.cn/problems/shifting-letters-ii/)

```java
class Solution {
    public String shiftingLetters(String s, int[][] shifts) {
        int n = s.length();
        // 差分的变化数组，并不直接求和得到原数组
        int[] d = new int[n + 1];

        for(int[] shift: shifts) {
            int start = shift[0], end = shift[1], dir = shift[2];
            if (dir == 0) {
                dir = -1;
            }
            d[start] += dir;
            d[end + 1] -= dir;
        }

        // 前缀和
        for(int i = 1; i < n; i++) {
            d[i] += d[i - 1];
        }

        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < n; i++) {
            int c = s.charAt(i) - 'a';
            c = (c + d[i] % 26 + 26) % 26;
            sb.append((char) (c + 'a'));
        }
        return sb.toString();
    }
}
```

下面是传统的差分数组的写法，需要定义`d[0]`才能使用前缀和计算原数组。

```java
class Solution {
    public String shiftingLetters(String s, int[][] shifts) {
        int n = s.length();
        int[] d = new int[n + 1];

        // 传统的差分数组，第一项d[0] = s[0]
        d[0] = s.charAt(0) - 'a';
        for (int i = 1; i < n; i++) {
            d[i] = s.charAt(i) - s.charAt(i - 1);
        }

        for (int[] shift : shifts) {
            int start = shift[0], end = shift[1], dir = shift[2];
            if (dir == 0) {
                dir = -1;
            }
            d[start] += dir;
            d[end + 1] -= dir;
        }

        // 前缀和
        for (int i = 1; i < n; i++) {
            d[i] += d[i - 1];
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            int x = ((d[i] % 26) + 26) % 26 + 'a';
            sb.append((char) x);
        }
        return sb.toString();
    }
}
```

### [1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

这题比较坑的是下标的问题。

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] res = new int[n];
        int[] d = new int[n + 2];
        for(int[] booking: bookings) {
            int s = booking[0], e = booking[1], se = booking[2];
            d[s] += se;
            d[e + 1] -= se;
        }

        // 这里要取到n
        for(int i = 1; i <= n; i++) {
            d[i] += d[i - 1];
        }

        for(int i = 0; i < n; i++) {
            res[i] = d[i + 1];
        }

        return res;
    }
}
```

# 双指针算法

## 例题：

### [6156. 得到 K 个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/)

```java
class Solution {
    public int minimumRecolors(String s, int k) {
        int n = s.length();
        int res = k;
        for(int i = 0, j = 0, cnt = 0; j < n; j++) {
            if (s.charAt(j) == 'W') {
                cnt++;
            }

            // 如果i滑出了滑动窗口，要维护cnt的大小
            if (i <= j - k) {
                if (s.charAt(i) == 'W') {
                    cnt--;
                }
                i++;
            }
            
            // 有窗口了，要开始维护res了
            if (j >= k - 1) {
                res = Math.min(res, cnt);
            }
        }
        return res;
    }
}
```

# 题目

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

dp问题：

子问题：找以下标为i结束的前面的最大子数组和

未优化的版本：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int n = nums.length;
        for(int i = 0; i < n; i++) {
            res = Math.max(res, getMax(nums, i));
        }
        
        return res;
    }


    public int getMax(int[] nums, int cur) {
        if (cur == nums.length) {
            return 0;
        }
        int nextMax = getMax(nums, cur + 1);
        // 如果后面的答案对当前的答案有增益，则加，否则不处理
        return nums[cur] + (nextMax > 0 ? nextMax: 0);
    }
}
```

严格表结构：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int n = nums.length;
        int[] dp = new int[n + 1];
        // base case为0，所以不用手动填写
        for(int i = n - 1; i >= 0; i--) {
            dp[i] = nums[i] + ( dp[i + 1] > 0 ? dp[i + 1] : 0);
            res = Math.max(res, dp[i]); 
        }
        
        return res;
    }
}
```

## [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

dp问题：

递归解法：返回值维护一个最大值和最小值。每次都只有3种可能性，

1. `nums[cur]`最大 or 最小。
2. `nums[cur] * max`最大 or 最小
3. `nums[cur] * min` 最大 or 最小。

这样可以忽略正负号的影响，因为在计算最大值 or 最小值的时候，把三者都计算进去了。

```java
class Solution {
    public static class ReturnInfo {
        public int max;
        public int min;

        public ReturnInfo(int x, int i) {
            this.max = x;
            this.min = i;
        }
    }

    private ReturnInfo[] dp;

    public int maxProduct(int[] nums) {
        int res = Integer.MIN_VALUE;
        int n = nums.length;
        dp = new ReturnInfo[n + 1];
        for(int i = 0; i < n; i++) {
            int x = getMax(nums, i).max;
            res = Math.max(res, x);
        }
        
        return res;
    }

    public ReturnInfo getMax(int[] nums, int cur) {
        if (dp[cur] != null ) {
            return dp[cur];
        }

        // 返回1,1不影响结果
        if ( cur == nums.length) {
            dp[cur] = new ReturnInfo(1, 1);
            return dp[cur];
        }
        ReturnInfo nextReturn = getMax(nums, cur + 1);
        // 不用管正负，因为如果min为负数或者max为负数，在执行Math.min()和Math.max()都把这种可能性算进去了
        int max = Math.max(nums[cur], Math.max(nextReturn.max * nums[cur], nextReturn.min * nums[cur]));
        int min = Math.min(nums[cur], Math.min(nextReturn.max * nums[cur], nextReturn.min * nums[cur]));
        dp[cur] = new ReturnInfo(max, min);
        return dp[cur];
    }
}
```

严格表结构，效率和记忆化搜索差不多。

```java
class Solution {
    public static class ReturnInfo {
        public int max;
        public int min;

        public ReturnInfo(int x, int i) {
            this.max = x;
            this.min = i;
        }
    }

    private ReturnInfo[] dp;

    public int maxProduct(int[] nums) {
        int res = Integer.MIN_VALUE;
        int n = nums.length;
        dp = new ReturnInfo[n + 1];
        // base case
        dp[n] = new ReturnInfo(1, 1);
        for(int i = n - 1; i >= 0; i--) {
            ReturnInfo nextReturn = dp[i + 1];
            int max = Math.max(nums[i], Math.max(nextReturn.max * nums[i], nextReturn.min * nums[i]));
            int min = Math.min(nums[i], Math.min(nextReturn.max * nums[i], nextReturn.min * nums[i]));
            dp[i] = new ReturnInfo(max, min);
            res = Math.max(res, max);
        }
        
        return res;
    }
}
```

## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

dp问题：

用两个指针指向字符串，那么就会有3种情况

1. 其中一个字符串结束了，那么编辑距离就是剩下的字符串的长度。
2. 两个字符串的指针指向的字符相同，那么编辑距离=dfs(i+1, j+1)
3. 如果不相同，则会出现编辑：插入、替换、删除。

插入可以理解成长的字符串删除了一个字符，所以和删除是一样的。

```java
class Solution {
    public int minDistance(String word1, String word2) {
        return dfs(word1, word2, 0, 0);
    }

    public int dfs(String word1, String word2, int i, int j) {
        
        // i的指针指向了word1的结尾，此时的编辑距离为word2剩下的长度
        if (i == word1.length()) {
            return word2.length() - j;
        }

        // 和上面的分支同理
        if(j == word2.length()) {
            return word1.length() - i;
        }

        // 如果两个字符串此时的字符相等，则往前推进
        if (word1.charAt(i) == word2.charAt(j)) {
            return dfs(word1, word2, i + 1, j + 1);
        }

        // 如果此时的两个字符不相等，则会发生编辑，编辑距离+1。有三种情况。
        return Math.min(
            // 替换
            dfs(word1, word2, i + 1, j + 1),
            Math.min(
                // 插入
                dfs(word1, word2, i + 1, j),
                // 删除
                dfs(word1, word2, i, j + 1)
            )
        ) + 1;
    }
}
```

记忆化搜索：

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for(int[] d : dp) {
            Arrays.fill(d, -1);
        }

        return dfs(dp, word1, word2, 0, 0);
    }


    public int dfs(int[][] dp, String word1, String word2, int i, int j) {
        if(dp[i][j] != -1) {
            return dp[i][j];
        }
        
        // i的指针指向了word1的结尾，此时的编辑距离为word2剩下的长度
        if (i == word1.length()) {
            dp[i][j] = word2.length() - j;
            return dp[i][j];
        }

        // 和上面的分支同理
        if(j == word2.length()) {
            dp[i][j] =  word1.length() - i;
            return dp[i][j];
        }

        // 如果两个字符串此时的字符相等，则往前推进
        if (word1.charAt(i) == word2.charAt(j)) {
            dp[i][j] = dfs(dp, word1, word2, i + 1, j + 1);
            return dp[i][j];
        }

        // 如果此时的两个字符不相等，则会发生编辑，编辑距离+1。有三种情况。
        dp[i][j] = Math.min(
            // 替换
            dfs(dp, word1, word2, i + 1, j + 1),
            Math.min(
                // 插入
                dfs(dp, word1, word2, i + 1, j),
                // 删除
                dfs(dp, word1, word2, i, j + 1)
            )
        ) + 1;
        return dp[i][j];
    }
}
```

## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

解法：

枚举每一个字字符串，看是否为回文串，如果为回文串，并且长度更长，则更新结果。

判断是否为回文串，用dp记录一下[i....j]是否已经计算过，如果计算过则返回，否则`f(i, j) = s[i] == s[j] && f(i + 1, j -1);`

```java
	public String longestPalindrome(String s) {
        int n = s.length();
        String res = "";
        Boolean[][] dp = new Boolean[n + 1][n + 1];

        for(int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                if (isPalindrome(dp, s, i, j) && j - i + 1 > res.length()) {
                    res = s.substring(i, j + 1);
                }
            }
        }
        return res;
    }

    public boolean isPalindrome(Boolean[][] dp, String s, int i, int j) {

        if (dp[i][j] != null) {
            return dp[i][j];
        }

        if (i == j) {
            dp[i][j] = true;
        } else if (i + 1 == j) {
            dp[i][j] = s.charAt(i) == s.charAt(j);
        } else {
            dp[i][j] = (s.charAt(i) == s.charAt(j) && isPalindrome(dp, s, i + 1, j - 1));
        }

        return dp[i][j];
    }
```

## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

dp问题，子问题就是 如果两个字符串s1 s2，s1[0] == s2[0]，可转换成s1[1:] 和 s2[1:]的最长公共子序列。

递归解法（未ac，超时）

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        return longestCommonSubsequence(text1, text2, 0, 0);
    }

    public int longestCommonSubsequence(String text1, String text2, int i, int j) {
        // base case
        if (i == text1.length() || j == text2.length()) {
            return 0;
        }
        if (text1.charAt(i) == text2.charAt(j)) {
            return longestCommonSubsequence(text1, text2, i + 1, j + 1) + 1;
        }
        return Math.max(longestCommonSubsequence(text1, text2, i + 1, j), longestCommonSubsequence(text1, text2, i, j + 1));
    }
}
```

记忆化搜索，（ac）

```java
class Solution {
    private int[][] dp;
    public int longestCommonSubsequence(String text1, String text2) {
        dp = new int[text1.length() + 1][text2.length() + 1];
        for(int[] d: dp) {
            Arrays.fill(d, -1);
        }
        return longestCommonSubsequence(text1, text2, 0, 0);
    }

    public int longestCommonSubsequence(String text1, String text2, int i, int j) {
        if(dp[i][j] != -1) {
            return dp[i][j];
        }
        if (i == text1.length() || j == text2.length()) {
            dp[i][j] = 0;
        } else if (text1.charAt(i) == text2.charAt(j)) {
            dp[i][j] = longestCommonSubsequence(text1, text2, i + 1, j + 1) + 1;
        } else {
            dp[i][j] = Math.max(longestCommonSubsequence(text1, text2, i + 1, j), longestCommonSubsequence(text1, text2, i, j + 1));
        }
        return dp[i][j];    
    }
}
```

## [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

dp问题：

先用dfs模拟跳跃。
```java
class Solution {
    public int jump(int[] nums) {
        int res = dfs(nums, 0);
        return res;
    }

    public int dfs(int[] nums, int curIdx) {

        if (curIdx >= nums.length - 1) {
            return 0;
        }

        int tmp = nums[curIdx];
        int res = Integer.MAX_VALUE;
        while (tmp > 0) {
            // 开始跳
            int r = dfs(nums, curIdx + (tmp--));
            if (r != -1) {
                res = Math.min(res, r + 1);
            }
        }
        // -1表示跳不到，在nums[curIdx] = 0时，是不可达的
        res = res == Integer.MAX_VALUE ? -1 : res;
        return res;
    }
}
```

记忆化搜索：

```java
class Solution {
    private int[] dp;
    public int jump(int[] nums) {
        dp = new int[nums.length + 1];
        Arrays.fill(dp, -2);
        int res = dfs(nums, 0);
        return res;
    }

    public int dfs(int[] nums, int curIdx) {
        if (curIdx >= nums.length) {
            return 0;
        }
        if (dp[curIdx] != -2) {
            return dp[curIdx];
        }

        if (curIdx == nums.length - 1) {
            dp[curIdx] = 0;
            return dp[curIdx];
        }

        int tmp = nums[curIdx];
        int res = Integer.MAX_VALUE;
        while (tmp > 0) {
            int r = dfs(nums, curIdx + (tmp--));
            if (r != -1) {
                res = Math.min(res, r + 1);
            }
        }
        dp[curIdx] = res == Integer.MAX_VALUE ? -1 : res;
        return dp[curIdx]; 
    }
}
```

优化成dp表的代码：

```java
class Solution {
    private int[] dp;
    public int jump(int[] nums) {
        int n = nums.length;
        // 是否为n+1影响不大
        dp = new int[n];
        
        // basecase 为 dp[n - 1] = 0
        // 所以下面的从n-2开始往下循环
        for(int i = n - 2; i >= 0; i--) {
            int tmp = nums[i];
            // 这里比较坑，不能使用Integer.MAX_VALUE，不然会溢出.....
            dp[i] = 1 << 31 -1;
            for(int j = 1; j <= tmp; j++ ) {
                if (i + j < n) {
                    dp[i] = Math.min(dp[i], dp[i + j] + 1);
                }
            }
        }
        return dp[0];
    }
}
```

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

解法：

使用滑动窗口，用哈希表来存放不同元素的最大的下标。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 左边界
        int l = 0;
        int n = s.length();
        int res = 0;
        Map<Character, Integer> window = new HashMap<>();
        for(int r = 0; r < n; r++) {
            // 如果包含了当前字符，说明有重复字符，需要移动左边界。
            if (window.containsKey(s.charAt(r))) {
                // 这里使用max的原因是：如果不使用，则在abba 的这种情况下，在r指针指向最后一个a的时候，l会往回挪。
                l = Math.max(l, window.get(s.charAt(r)) + 1);
            }
            window.put(s.charAt(r), r);
            res = Math.max(res, r - l + 1);
        }
        return res;
    }
}
```

![1](无重复字符的最长子串/1.jpg)

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

解法：

求i-j的的面积，有三种情况

1. i-j就是最大的
2. i+1,j中会有最大的
3. i,j - 1中会有最大的

优化前的：

```java
class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int[][] dp = new int[n][n];
        for(int[] d: dp) {
            Arrays.fill(d, -1);
        }
        return f(dp, height, 0, n - 1);
    }

    // i 和 j之间的最大面积
    public int f(int[][] dp, int[] height, int i, int j) {
        if(dp[i][j] != -1) {
            return  dp[i][j];
        }

        // base case: j - i == 1 return min(height[i], height[j])
        if (j - i == 1) {
            dp[i][j] = Math.min(height[i], height[j]);
            return dp[i][j];
        }
        int s = (j - i) * Math.min(height[i], height[j]);
        dp[i][j] = Math.max(s, Math.max( f(dp, height, i + 1, j), f(dp, height, i, j - 1)));
        return dp[i][j];
    }
}
```

优化后的

```java
class Solution {
    public int maxArea(int[] height) {
        return f(height, 0, height.length - 1);
    }

    // i 和 j之间的最大面积
    public int f(int[] height, int i, int j) {
        // base case: j - i == 1 return min(height[i], height[j])
        if (j - i == 1) {
            return Math.min(height[i], height[j]);
        }
        int tmp;
        // 因为面积是按照最矮的一条边来算的，s=x*h. 面积是无论如何都不会超过h*x的，x为最短边，但是如果移动高的则可能会变得更小。
        if (height[i] < height[j]) {
            tmp = f(height, i + 1, j);
        } else {
            tmp = f(height, i, j - 1);
        }

        int s = (j - i) * Math.min(height[i], height[j]);
        return Math.max(s, tmp);
    }
}
```

## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

解法：

维护一个单调栈，每次要破坏单调性的时候，计算接到的雨水。

在栈中，栈底的元素总是比栈顶要大（或者等于）的，所以当要破坏单调性的时候，就说明出现了凹槽。

在重新维护单调栈的时候，先把栈顶元素出栈，原来栈顶下面的元素为left，此时待入栈的元素height[i]。

计算雨水的时候，计算的方式是计算每一层的接到的雨水（每次pop元素的时候，都是计算该元素被两边夹住的高度差），高即为left和height[i]的最小值-刚出栈的元素的高度，宽度是pop的元素的两侧元素的下标差，并且需要减去待入栈的元素本身的宽度。

```java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        for(int i = 0; i < height.length; i++) {
            // 遇到破坏单调性的元素，重新入栈了，此时应该计算能接到的水的数量
            while(!stack.isEmpty() && height[stack.peek()] < height[i]) {
                int top = stack.pop();
                // 栈中至少要有两个元素
                if(stack.isEmpty()) {
                    break;
                }
                int left = stack.peek();
                int curLen = i - left - 1;
                // 每次都是计算top被夹住的情况
                int curHeight = Math.min(height[i], height[left]) - height[top];

                res += curHeight * curLen;

            }
            stack.push(i);
        }

        return res;
    }
}
```

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

同[11. 盛最多水的容器](#11-盛最多水的容器)，使用记忆化搜索。

可以一步一步的优化成自底向上的dp。

```java
class Solution {
    // 版本3
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[n][m];
        for(int i = 0; i < m; i++ ) {
            dp[0][i] = 1;
        }

        for(int i = 0; i < n; i++) {
            dp[i][0] = 1;
        }

        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[n - 1][m - 1];
    }
    
	// 版本2
    // public int uniquePaths(int m, int n) {
    //     int[][] dp = new int[n + 2][m + 2];
    //     for(int[] d: dp) {
    //         Arrays.fill(d, -1);
    //     }

    //     return dfs(dp, m, n, 1, 1);
    // }

    // public int dfs(int[][] dp,int m, int n, int x, int y) {
    //     if(dp[x][y] != -1) {
    //         return dp[x][y];
    //     }

    //     if (x > n || y > m) {
    //         dp[x][y] = 0;
    //     } else if (x == n && y == m) {
    //         dp[x][y] = 1;
    //     } else {
    //         dp[x][y] = dfs(dp, m, n, x + 1, y) + dfs(dp, m, n, x, y + 1);
    //     }

    //     return dp[x][y]; 
    // }
    
    // 版本1
	// public int uniquePaths(int m, int n) {
    //     return dfs(m, n, 1, 1);
    // }
    //
    // public int dfs(int m, int n, int x, int y) {
    //     if (x > n || y > m) {
    //         return 0;
    //     } else if (x == n && y == m) {
    //         return 1;
    //     }
    //
    //     return dfs(m, n, x + 1, y) + dfs(m, n, x, y + 1);
    // }
}
```

## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

经典的dp问题：

子问题：选与不选当前的最大值。

优化前的递归：

```java
class Solution {
    public int rob(int[] nums) {
        return rob(nums, 0);
    }

    public int rob(int[] nums, int cur) {
        if (cur >= nums.length) {
            return 0;
        }

        // 选了当前的就不能选之后第2个的。
        // 在选不选当前的决策上，取最大的。
        return Math.max(rob(nums, cur + 2) + nums[cur], rob(nums, cur + 1));
    }
}
```

记忆化搜索：

```java
class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[nums.length + 2];
        Arrays.fill(dp, -1);
        return rob(dp, nums, 0);
    }
    
    public int rob(int[] dp, int[] nums, int index) {
        if (dp[index] != -1) {
            return dp[index];
        }

        if (index >= nums.length) {
            dp[index] = 0;
        } else {
            dp[index] = Math.max(
                rob(dp, nums, index + 2) + nums[index],
                rob(dp, nums, index + 1));
        }
        return dp[index];
    }
}
```

严格表结构：

由上面的记忆化搜索改成严格表结构的时候，需要初始化

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n + 1];
        // 这里需要注意的是，下面的方程需要访问dp[i + 1]，但是在递归函数并不需要手动初始化，改成严格表结构需要初始化
        dp[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            dp[i] = Math.max(dp[i + 2] + nums[i], dp[i + 1]);
        }
        return dp[0];
    }
}
```

## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

经典的dp问题，用二维的dp数组存放。

子问题：

min(选择当前钱币；不选择当前的钱币，选择下一个钱币)

如果选择了当前的钱币，则答案需要+1，表示选择了钱币。

```java
class Solution {
    private int[][] dp;
    public int coinChange(int[] coins, int amount) {
        dp = new int[amount + 1][coins.length + 1];
        for(int[] d: dp) {
            Arrays.fill(d, -2);
        }
        return coinChange(coins, amount, 0, 0);
    }

    public int coinChange(int[] coins, int amount, int sum, int index) {
        if (sum > amount || index >= coins.length || sum < 0) {
            return -1;
        }

        if(dp[sum][index] != -2) {
            return dp[sum][index];
        }
		
        // 这里返回0是表示basecase，需要退出了，如果是在求零钱兑换的方式，这里返回1表示一种兑换方式，但是在这里是求硬币个数
        // 所以不能在这里返回1，需要在调用递归函数的时候计算。
        if (sum == amount) {
            dp[sum][index] = 0;
        } else {
            // 选择当前的硬币，并且可以再次选择相同的硬币，所以p1需要+1
            int p1 = coinChange(coins, amount, sum + coins[index], index);
            // 不选当前硬币，选择新的硬币
            int p2 = coinChange(coins, amount, sum, index + 1);
            if (p1 == -1 && p2 == -1) {
                dp[sum][index] = -1;
            } else if (p1 == -1) {
                dp[sum][index] = p2;
            }else if(p2 == -1) {
                dp[sum][index] = p1 + 1;
            }else {
                dp[sum][index] = Math.min(p1 + 1, p2);
            }
        }
        return dp[sum][index];
    } 
}
```

## [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

解法：

暴力循环，判断每个字串是否有效括号，并且记录下最长的长度。（未ac，超时）

```java
class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        int res = 0;
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                if(isValid(s, i, j)) {
                    res = Math.max(res, j - i + 1);
                }
            }
        }

        return res;
    }

    public boolean isValid(String s, int start, int end) {
        int balance = 0;
        for(int i = start; i <= end; i++) {
            if (s.charAt(i) == '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) {
                return false;
            }
        }
        return balance == 0;
    }
}
```

暴力循环优化版：增加缓存（未ac，内存超了）

```java
class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        int res = 0;
        Boolean[][] dp = new Boolean[n + 1][n + 1];
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                if(isValid(dp, s, i, j)) {
                    res = Math.max(res, j - i + 1);
                }
            }
        }

        return res;
    }

    public boolean isValid(Boolean[][] dp, String s, int start, int end) {
        if (dp[start][end] != null) {
            return dp[start][end];
        }
        int balance = 0;
        for(int i = start; i <= end; i++) {
            if (s.charAt(i) == '(') {
                balance++;
            } else {
                balance--;
            }
            if (balance < 0) {
                dp[start][end] = false;
                return dp[start][end];
            }
        }
        dp[start][end] = balance == 0;
        return dp[start][end];
    }
}
```

自底向上动态规划

放几个截图来说明这个问题：

![dp_1](最长有效括号/dp_1.jpg)![dp_1](最长有效括号/dp_2.jpg)

```java
class Solution {
    public int longestValidParentheses(String s) {
        int n = s.length();
        // dp[i]表示以`)`结尾的，前i个字符的最长有效括号的长度。
        // 如果在当前字符前 dp[i - 1] (前面一个以`)`结尾的最长有效括号长度)的字符前面一个字符为`(`，则dp[i] = dp[i - 1] + 2;
        // 如果跳到了前一个为`(`的字符串，前面的还有有效括号则需要接上一段
        int[] dp = new int[n + 1];
        int res = 0;
        for(int i = 1; i < n; i++) {
            if (s.charAt(i) == ')') {
                int pre = i - dp[i - 1] - 1;
                if( pre >= 0 && s.charAt(pre) == '(') {
                    dp[i] = dp[i - 1] + 2;
                    if (pre > 0) {
                        dp[i] += dp[pre - 1];
                    }
                }
                // 这里使用max是因为，最后一个字符可能是`(`，这样dp[i]为0，所以需要一个最大值存放答案
                res = Math.max(res, dp[i]);
            }
        }
        return res;
    }
}
```

## [剑指 Offer 46. 把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

两种解法：

子问题：max(开始选择一个字符翻译的结果数；开始选择2个字符的翻译结果数)。

但是在写代码的时候，需要注意的几个特例：

* 递归到了最后1个字符，则只能选择单字符翻译。
* 如果当前字符串为0，则必须单字符翻译，因为字符串如01，02，03等，是不能双字符翻译
* 如果当前字符和后面的字符合起来，在有效字符范围之外，如26、27等，只能选择单字符翻译。

一种解法是转换成字符串，递归。

```java
class Solution {
    public int translateNum(int num) {
        return translateNum(String.valueOf(num), 0);
    }

    public int translateNum(String s, int index) {
        int n = s.length();
        // base case 到头了，说明这种方式能行，返回1
        if (index == n) {
            return 1;
        }
        // 只剩最后一个字符，或者当前的字符为0，或者>=26 区间外边，后边的字符都是取一个
        if (index == n - 1 || s.charAt(index) == '0' || s.substring(index, index + 2).compareTo("26") >= 0) {
            return translateNum(s, index + 1);
        } else {
            return translateNum(s, index + 1) + translateNum(s, index + 2);
        }
    }
}
```

另一种比较高效，使用取模和除法巧妙递归。

```java
class Solution {
    public int translateNum(int num) {
        if (num == 0) {
            return 1;
        }
        // 最后两位是10- 26之间的，就可以用两种方法翻译。
        // 除法是为了取前1位（/100）或者前两位(/100)
        if (num%100 >= 10 && num%100 < 26) {
            return translateNum(num/10) + translateNum(num/100);
        // 否则就是一种翻译方式，并且取前1位
        } else {
            return translateNum(num/10);
        }
    }
}
```

## [300. 最长递增子序列(最长上升子序列)](https://leetcode.cn/problems/longest-increasing-subsequence/)

dp问题。

暴力递归：

把所有的最长上升子序列的长度都找出来，选择最大的那个。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int max = 0;

        // 由于没有自动寻路的功能，所以需要循环调用dfs函数
        for(int i = 0; i < nums.length; i++) {
            max = Math.max(max, lengthOfLIS(nums, i));
        }
        
        return max;
    }

    public int lengthOfLIS(int[] nums, int index) {
        int n = nums.length;
        // 遍历到了nums数组的结尾，退出函数
        if (index == n) {
            return 0;
        }

        // 上升子序列中已经有了nums[index]，所以长度为1
        int res = 1;
        // 从index+1开始算，可以少算一个
        for(int i = index + 1; i < n; i++) {
            if (nums[i] > nums[index]) {
                res = Math.max(res, lengthOfLIS(nums, i) + 1);
            }
        }
        return res;
    }
}
```

记忆化搜索：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int max = 0;
        int[] dp = new int[nums.length + 1];
        Arrays.fill(dp, -1);

        // 由于没有自动寻路的功能，所以需要循环调用dfs函数
        for(int i = 0; i < nums.length; i++) {
            max = Math.max(max, lengthOfLIS(dp, nums, i));
        }
        
        return max;
    }

    public int lengthOfLIS(int[] dp, int[] nums, int index) {
        int n = nums.length;
        if (dp[index] != -1) {
            return dp[index];
        }

        // 遍历到了nums数组的结尾，退出函数
        if (index == n) {
            dp[index] = 0;
            return dp[index];
        }

        // 上升子序列中已经有了nums[index]，所以长度为1
        int res = 1;
        // 从index+1开始算，可以少算一个
        for(int i = index + 1; i < n; i++) {
            if (nums[i] > nums[index]) {
                res = Math.max(res, lengthOfLIS(dp, nums, i) + 1);
            }
        }
        dp[index] = res;
        return dp[index];
    }
}
```

## 之字形打印矩阵

解法：固定两个点，一个点负责向下，一个点负责向右，每次都只打印两个点连起来的线。

```java
	public static void zigzagPrintMatrix(int[][] matrix) {
        // 点A往右边走
        int aRow = 0;
        int aCol = 0;
        // 点B往下边走
        int bRow = 0;
        int bCol = 0;
        int endRow = matrix.length;
        int endCol = matrix[0].length;
        boolean toDown = false;
        while (aRow != endRow) {
            printLevel(matrix, aRow, aCol, bRow, bCol, toDown);
            // 当a往右走，走到最后一列的时候，需要往下走
            aRow = aCol == endCol - 1 ? aRow + 1 : aRow;
            aCol = aCol == endCol - 1 ? aCol : aCol + 1;
            // 当b往下走，走到最后一行的时候，需要往右边走
            bCol = bRow == endRow - 1 ? bCol + 1 : bCol;
            bRow = bRow == endRow - 1 ? bRow : bRow + 1;
            toDown = !toDown;
        }
    }

    public static void printLevel(int[][] matrix, int aRow, int aCol, int bRow, int bCol, Boolean toDown) {
        if (toDown) {
            // 从上往下打印
            while (aRow <= bRow) {
                System.out.println(matrix[aRow++][aCol--]);
            }
        } else {
            // 从下网往打印
            while (bCol <= aCol) {
                System.out.println(matrix[bRow--][bCol++]);
            }
        }
    }
```

## 螺旋打印矩阵

与之字形打印矩阵一样，控制两个点从外往内移动，打印这两个点之间的轨迹就行。

```java
public static void spiralPrint(int[][] matrix) {
        int aRow = 0, aCol = 0;
        int bRow = matrix.length - 1, bCol = matrix[0].length - 1;

        while (aRow <= bRow && aCol <= bCol) {
            printCircle(matrix, aRow++, aCol++, bRow--, bCol--);
        }
    }

    public static void printCircle(int[][] matrix, int aRow, int aCol, int bRow, int bCol) {
        if (aRow == bRow) {
            for (int i = aCol; i <= bCol; i++) {
                System.out.printf("%d\t", matrix[aRow][i]);
            }
        } else if (aCol == bCol) {
            for (int i = aRow; i <= bRow; i++) {
                System.out.printf("%d\t", matrix[i][aCol]);
            }
        } else {
            int curRow = aRow, curCol = aCol;
            while (curCol < bCol) {
                System.out.printf("%d\t", matrix[curRow][curCol++]);
            }
            while (curRow < bRow) {
                System.out.printf("%d\t", matrix[curRow++][curCol]);
            }
            while (curCol > aCol) {
                System.out.printf("%d\t", matrix[curRow][curCol--]);
            }
            while (curRow > aRow) {
                System.out.printf("%d\t", matrix[curRow--][curCol]);
            }
        }
    }
```

## [155. 最小栈](https://leetcode.cn/problems/min-stack/)

解法：

维护两个栈，一个普通的栈，一个栈顶为最小值的栈，两个栈同进同出，在push值的时候，最小栈检查栈顶的值与push进来的值哪个最小，把最小值入栈（如果原来的元素就在栈内，也必须入栈，因为要保证和另一个栈同进同出）

![1](最小栈/1.png)

## [判断两个字符串是否互为旋转词](https://www.nowcoder.com/questionTerminal/687deda2cc57473499e058207f6258cf)

解法：

把母串复制一遍，拼在母串后面，看字串是否为拼接后的字符串的子串。

## 达标字符串

![1](达标字符串/1.png)

## [46. 全排列](https://leetcode.cn/problems/permutations/)

解法：

使用回溯。每次都交换两个数

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> clone = new ArrayList<>();

        for (int n : nums) {
            clone.add(n);
        }
        permute(clone, res, 0, clone.size() );
        return res;
    }

    private void permute(List<Integer> nums, List<List<Integer>> res, int start, int end) {
        if (start >= end) {
            res.add(new ArrayList<>(nums));
        }
        
        // 遍历 start - end，每次交换两个数
        for (int i = start; i < end; i++ ) {
            Collections.swap(nums, start, i);
            permute(nums, res, start + 1, end);
            Collections.swap(nums, start, i);
        }
    }
}
```

## [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

解法：

最开始在矩阵右上角，如果比目标数大，就往下搜，如果比目标数小，往左边搜，直到成功搜索到，否则说明矩阵中没有此元素。和[螺旋打印矩阵](#螺旋打印矩阵)类似，都是用有限几个点控制，而非关注细节。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        int r = 0, c = matrix[0].length - 1;
        int m = matrix.length;
        while(r < matrix.length && c >=0 ) {
            if (matrix[r][c] == target) {
                return true;
            } else if (r < m && matrix[r][c] < target) {
                r++;
            } else if (c >=0 && matrix[r][c] > target) {
                c--;
            }
        }
        return false;
    }
}
```

## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

解法：

看左右子树是否包含给定的节点，如果左右子树都包含则说明root为给定节点的最近公共祖先，如果只有左子树或者右子树一边包含，则需要在右子树/左子树中重复上述步骤递归搜索。

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 如果搜索到了就返回
        if (root == null || root.val == p.val || root.val == q.val) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) {
            return root;
        }
        if (left != null ) {
            return left;
        }
        if (right != null) {
            return right;
        }
        // 没有公共节点
        return null;
    }
}
```

## [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

解法：

暴力（超时，未ac）：枚举每个矩形，计算最小值。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        // brute force：遍历所有的，然后依次选择1个，2个....选出最大值
        int res = heights[0];
        for(int i = 0; i < heights.length; i++) {
            int min = heights[i];
            for(int j = i; j < heights.length; j++) {
                min = min > heights[j] ? heights[j] : min;
                res = Math.max(res, min * (j - i + 1));
            }
        }
        return res;
    }
}
```

双指针递归（和暴力一样，未ac）与[盛最多水的容器](#11. 盛最多水的容器)类似，但是不同的是，后者需要两根柱子才能形成一个矩形，但是本题单个柱子就能形成一个矩形。

子问题：如何找到一个最小的矩形。

1. 找到最小的柱子。
2. 以该柱子为中心，向两边扩展，计算最大值。
3. 拓展时递归的调用上面的步骤。

虽然没有ac，但是思想可以学习一下。

![1](柱状图中最大的矩形/1.png)

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        return rec(heights, 0, n - 1);
    }

    public int rec(int[] heights, int i, int j) {
        // base case：如果 i > j 说明需要退出了
        if (i > j ) {
            return 0;
        }
        int min = getMin(heights, i, j);
        int s = heights[min] * (j - i + 1);

        int left = rec(heights, i, min - 1);
        int right = rec(heights, min + 1, j);

        return Math.max(s, Math.max(left, right));
    }

    public int getMin(int[] heights, int s, int e) {
        int min = s;
        for(int i = s; i <= e; i++) {
            min = heights[i] < heights[min] ? i : min;
        }
        return min;
    }
}
```

## [1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

dp问题：

超时未ac。本题的数组长度量级在 `10^5` 级别，如果使用常规dfs或者常规dp(这里要用三维数组了)，会超时或者超内存。

```java
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        return dfs(cardPoints, k, 0, cardPoints.length - 1);
    }

    public int dfs(int[] cardPoints, int k, int l, int r) {
        if (k <= 0) {
            return 0;
        }

        int p1 = dfs(cardPoints, k - 1, l + 1, r) + cardPoints[l];
        int p2 = dfs(cardPoints, k - 1, l, r - 1) + cardPoints[r];
        return Math.max(p1, p2);
    }
}
```

## [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

时间复杂度要求`O(nlogn)`，所以考虑堆。

```java
class Solution {
    /**
    * 定义一个键值对 元素 和 频次；
    * 并且定义按照频次的大小排序的方法。
    */
    private static class Pair {
        public int ele;
        public int cnt;

        public Pair(int ele, int cnt) {
            this.ele = ele;
            this.cnt = cnt;
        }

        public boolean cmp(Pair other) {
            return this.cnt > other.cnt;
        }
    }

    /**
    * 大根堆
    */
    public static class Heap {
        private Pair[] h;
        private int tail;

        public Heap(int n) {
            // 下标从1开始，所以为n + 1;
            this.h = new Pair[n + 1];
            this.tail = 0;
        }

        public Pair popMax() {
            Pair res = h[1];
            h[1] = h[tail--];
            down(1);
            return res;
        }

        public void insert(Pair p) {
            if (tail >= h.length) {
                return;
            }
            // 先++是因为：
            // 1. tail初始指向了0位置
            // 2. 在pop的时候，有些数据不会删除，而是在insert的时候覆盖
            h[++tail] = p;
            up(tail);
        }

        public void down(int i) {
            int max = i;
            int leftIdx = getLeftIdx(i);
            int rightIdx = getRightIdx(i);
            if (leftIdx <= tail && h[leftIdx].cmp(h[max])) {
                max = leftIdx;
            }
            if (rightIdx <= tail && h[rightIdx].cmp(h[max])) {
                max = rightIdx;
            }

            if (max != i) {
                swap(h, max, i);
                down(max);
            }
        }

        public void up(int i) {
            int fa = i / 2;
            while (fa >= 1 && h[i].cmp(h[fa])) {
                swap(h, fa, i);
                i /= 2;
                fa = i / 2;
            }
        }

        private void swap(Pair[] nums, int i, int j) {
            Pair tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }

        private int getLeftIdx(int i) {
            return i * 2;
        }

        private int getRightIdx(int i) {
            return i * 2 + 1;
        }

        public int getSize() {
            return tail;
        }
    }

    public int[] topKFrequent(int[] nums, int k) {
        Heap heap = new Heap(nums.length);
        Map<Integer, Pair> map = new HashMap<>();
        for (int n : nums) {
            map.compute(n, (key, v) -> {
                if (v == null) {
                    v = new Pair(key, 1);
                } else {
                    v.cnt++;
                }
                return v;
            });
        }

        map.forEach((key, v) -> {
            heap.insert(v);
        });

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = heap.popMax().ele;
        }

        return res;
    }
}
```

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

注意边界就行。

前序遍历 左子树的右端点为：前序start + 中序遍历头节点所在下标(i) - 中序start。
前序遍历 右子树的左端点为：上面求的+1。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    public TreeNode buildTree(int[] preorder, int ps, int pe, int[] inorder, int is, int ie) {
        if (is > ie || ps > pe) {
            return null;
        }

        TreeNode root = new TreeNode(preorder[ps]);
        for(int i = is; i <= ie; i++) {
            if (inorder[i] == preorder[ps] ) {
                root.left = buildTree(preorder, ps + 1, ps + i - is, inorder, is, i - 1);
                root.right = buildTree(preorder, ps + i - is + 1, pe, inorder, i + 1, ie);
            }
        }
        return root;
    }
}
```

## [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

滑动窗口和dp问题：

滑动窗口：

因为题目要求了连续，所以可以使用滑动窗口来进行解题：

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int l = 0, r = 1;
        int res = 0;
        while(r <= nums.length) {
            
            while(r < nums.length && nums[r] > nums[r - 1]) {
                r++;
            }

            // 如果是遇到遍历数组结束了，就可以返回答案了
            if (r == nums.length) {
                res = Math.max(res, r - l);
                break;
            }
    
            // 是遇到了 nums[r] < nums[r - 1] 而结束的，窗口左边界应该收缩了
            if (nums[r] <= nums[r - 1]) {
                res = Math.max(res, r - l);
                l = r;
            }

            // 移动右边界
            r++;
        }

        return res;
    }
}
```

动态规划：

```java
```
