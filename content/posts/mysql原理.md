---
title: "Mysql原理"
date: 2022-07-31T23:31:00+08:00
draft: false
---


# 执行结构

总体分为两个部分：

server 和 执行引擎

## server

连接器->分析器->优化器->执行器。

连接器：负责管理连接。超时断开、用户密码校验。

分析器：词法分析。

优化器：优化查询。

执行器：执行语句，权限校验。

## 执行引擎

常见的有innodb和myaism。

# redolog和binlog

## redolog

redolog为innodb实现的。

对数据库做的更新操作不直接写入磁盘，而是通过write ahead log的技术写入redolog。在空闲的时候，把redolog中的改动同步到磁盘。

图源：https://blog.csdn.net/weixin_43213517/article/details/117457184

![innodb_redolog](.\innodb_redolog.png)

### 为什么需要redolog？

innodb是以页的方式来管理存储空间的，在进行增删改的时候，需要把记录所在的整个页加载到buffer pool（内存）中，在内存做完写操作之后，再进行刷盘，刷盘为随机IO，开销太大。

### redolog如何持久化

#### 刷盘时机

1. 后台定时刷盘。
2. 用户commit时。

#### 两个指针

write position和checkpoint。

redolog为环形log，当wp追上了checkpoint，就要刷盘了，这个时候把checkpoint往前推进，才可以继续写。

## binlog

binlog为server的日志，不归属任何执行引擎，所有执行引擎都可以用。

和redolog有几点不同：

1. binlog为逻辑日志，而redolog为物理日志。binlog会记录下“给哪一行更新id=2”，而redolog会记录下“在哪个数据页的哪一行进行修改”。
2. redolog循环写，空间会用完，binlog为追加写，理论上无限大。

## 两阶段写

总体和分布式事务一个思想，以更新为例子：

1. 执行器找执行引擎取目标记录，执行引擎用树来找这一条记录，如果在内存则直接返回，如果不在内存，则将该记录所在的整个页加载到内存，再返回。
2. 执行器在内存更新完成该记录，再调用引擎的接口写入这行数据。
3. 执行引擎在内存中更新这条数据，并且把更新记录写入redolog，把redolog的状态置为prepare状态，并且告知执行器可以写binlog。
4. 执行器写binlog，把binlog写入磁盘。
5. 执行器再调用执行引擎的接口把redolog的状态改为commit。

如果在写的时候出现的crash，该怎么恢复？

1. 如果redolog中的事务是完整的（有commit标识），则直接commit。
2. 如果redolog只有prepare，则去看binlog事务是否完整。
a. 如果binlog存在事务并且完整，则改redolog为commit，然后commit事务。
b. 如果binlog事务不完整，则直接回滚。

# 事务

## 事务会出现的问题



## 事务隔离级别





# 索引

## 分类

分为三种：hashtable、顺序表、b+树。

### hashtable

hashtable因为无序所以插入性能比较好，对于等值查询的情况比较好，但是因为无序，对于区间查询则显得比较慢。

### 顺序表

顺序表（非链表）在因为有序所以在区间查询的条件下表现的比较优秀，但是由于要保证顺序，在插入的时候，开销的比较大需要把元素整体往后挪。

### b+树

b+树的定义是：

**1)** 有n棵子树的节点中含有n个关键字(即每个关键字对应一棵子树)；

**2)** 所有叶子节点中包含了全部关键字的信息， 及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；

**3)** 所有的非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中的最大（或最小)关键字

**4)** 除根节点外，其他所有节点中所含关键字的个数必须`>=⌈m/2⌉`(注意： `B-树`是除根以外的所有非终端节点至少有`⌈m/2⌉`棵子树)

上面的定义是从网上扒下来的，用大白话说就是：

1. 非叶子节点不保存数据，只用来当作索引，真正存储数据的是叶子节点。
2. 每节点都仅含其子节点的最大或者最小的关键字。
3. 叶子节点
4. 在查询的时候，都会查询到叶子节点，而不是查询到某个节点值相等就停下。

![](.\b+树.png)

## 页分裂和页合并

b+树在插入的时候有算法，那就是会限制一个节点所能持有的最大关键字的个数，则会申请一个内存页，把一部分的数据挪过去。影响了性能和整体空间利用率。

同样的，如果有相邻页面删除了数据，也会触发b+树的平衡把相邻的页数据合并到一页。

## 回表

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵B+ 树

如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，**再到 ID 索引树搜索一次**。这个过程称为**回表**。

## 覆盖索引

有一个表person index:(primary_key: id) (id_card,name) (name,age)

| id   | id_card | name | age  | ismale |
| ---- | ------- | ---- | ---- | ------ |

```sql
select * from person where age between 10 and 30;
```

这样会有回表的情况，而直接查询主键，就不会造成回表的情况。因为在查询索引时已经确认了目标字段。

```sql
select id from person where age between 10 and 30;
```

不光主键，只要是在查询的时候涉及到目标字段就能实现索引覆盖。在上面设置了一个组合索引（id_card,name)，这样也不会回表。

```sql
select id_card from person where name like 'Jecky%';
```



## 最左前缀匹配原则

复合索引如何节省索引个数呢？

先说结论：

b+树可以用最左前缀匹配原则来定位记录，最左前缀可以是字符串索引的最左m个字符，也可以是复合索引的最左n个字段。

如上面的（name,age)复合索引，在下面查询语句中，也可以使用到这个索引，最左边的字段再加上字符串索引的最左n个字符。

```sql
select * from person where name like 'Jecky%';
```

所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。

但是如果查询语句中只有一个age是不能触发索引的。因为需要加上name查询条件才能走索引。

```sql
select * from person where age between 10 and 30;
```

此时可以给age新建一个单独的索引。

## 索引下推

在回表之前可以根据条件筛选掉一部分数据，避免回表的数据比较多。

例如：

```sql
select * from person where name like 'Jecky%' and age between 10 and 30;
```

使用索引查询出以jecky为前缀的，并且在非主键b+树中筛选掉了age在10-30之间的，**只会让那些已经满足该条件的记录回表**。

# 锁

## 表锁

#### 读写锁

lock table ... read/write

读锁与读锁之间没有冲突，但是加了读锁之后其他线程加写锁会卡住。

加了写锁，其他线程的读和写锁就都会锁定。

同时一个线程加了读锁，在unlock table之前只能读该表。

### mdl

在**修改表结构**的时候加的锁，也分为读锁和写锁。读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。

所有对表的增删改查操作都需要先申请MDL 读锁。

但是mdl写锁加了之后，其他线程在进行增删改查的时候申请mdl读锁也会卡住。

## 行锁

### 两段锁协议

在innodb事务中，对一行加的锁不是在写完这一行结束之后就释放，而是在事务结束的时候才会释放。

行锁可能会造成死锁，a和b两个线程开启了事务，并且都持有了对方要锁的记录，就会造成死锁。



