<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Go语言原理 | Secret Room of KyrieXu11</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="函数调用 栈调用 栈的地址是由上到下从高地址到低地址的。
go语言的函数调用栈从栈基础地址开始，依次填入局部变量、调用的目标函数的返回值和参数。如果函数有多个参数和返回值是从代码顺序的右到左依次压入栈。
返回地址是下一条指令的地址，函数执行完之后会跳转到这里。
并且go语言分配栈空间是一次性分配最大的所需栈空间，因为栈空间在编译期间就可确定，所以可以通过后面要说的morestack进行检测，如果分配的不够则会进行栈增长，另外的开辟一块足够大的栈空间，把原来栈上的数据拷贝到新的空间。
举个例子
func incrNumB(a int) int { var b int defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB(a) fmt.Println(a, b) // 输出 0 1 } 在defer函数执行之前，会先给返回值赋值，也就是先给栈上的返回值区域先赋值从0变为1，再执行defer函数。
func incrNumB1(a int) (b int) { defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB1(a) fmt.">
    <meta name="generator" content="Hugo 0.102.0-DEV" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Go语言原理" />
<meta property="og:description" content="函数调用 栈调用 栈的地址是由上到下从高地址到低地址的。
go语言的函数调用栈从栈基础地址开始，依次填入局部变量、调用的目标函数的返回值和参数。如果函数有多个参数和返回值是从代码顺序的右到左依次压入栈。
返回地址是下一条指令的地址，函数执行完之后会跳转到这里。
并且go语言分配栈空间是一次性分配最大的所需栈空间，因为栈空间在编译期间就可确定，所以可以通过后面要说的morestack进行检测，如果分配的不够则会进行栈增长，另外的开辟一块足够大的栈空间，把原来栈上的数据拷贝到新的空间。
举个例子
func incrNumB(a int) int { var b int defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB(a) fmt.Println(a, b) // 输出 0 1 } 在defer函数执行之前，会先给返回值赋值，也就是先给栈上的返回值区域先赋值从0变为1，再执行defer函数。
func incrNumB1(a int) (b int) { defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB1(a) fmt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kyriexu11.github.io/posts/go%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T23:31:00+08:00" />
<meta property="article:modified_time" content="2022-07-28T23:31:00+08:00" />

<meta itemprop="name" content="Go语言原理">
<meta itemprop="description" content="函数调用 栈调用 栈的地址是由上到下从高地址到低地址的。
go语言的函数调用栈从栈基础地址开始，依次填入局部变量、调用的目标函数的返回值和参数。如果函数有多个参数和返回值是从代码顺序的右到左依次压入栈。
返回地址是下一条指令的地址，函数执行完之后会跳转到这里。
并且go语言分配栈空间是一次性分配最大的所需栈空间，因为栈空间在编译期间就可确定，所以可以通过后面要说的morestack进行检测，如果分配的不够则会进行栈增长，另外的开辟一块足够大的栈空间，把原来栈上的数据拷贝到新的空间。
举个例子
func incrNumB(a int) int { var b int defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB(a) fmt.Println(a, b) // 输出 0 1 } 在defer函数执行之前，会先给返回值赋值，也就是先给栈上的返回值区域先赋值从0变为1，再执行defer函数。
func incrNumB1(a int) (b int) { defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB1(a) fmt."><meta itemprop="datePublished" content="2022-07-28T23:31:00+08:00" />
<meta itemprop="dateModified" content="2022-07-28T23:31:00+08:00" />
<meta itemprop="wordCount" content="4770">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go语言原理"/>
<meta name="twitter:description" content="函数调用 栈调用 栈的地址是由上到下从高地址到低地址的。
go语言的函数调用栈从栈基础地址开始，依次填入局部变量、调用的目标函数的返回值和参数。如果函数有多个参数和返回值是从代码顺序的右到左依次压入栈。
返回地址是下一条指令的地址，函数执行完之后会跳转到这里。
并且go语言分配栈空间是一次性分配最大的所需栈空间，因为栈空间在编译期间就可确定，所以可以通过后面要说的morestack进行检测，如果分配的不够则会进行栈增长，另外的开辟一块足够大的栈空间，把原来栈上的数据拷贝到新的空间。
举个例子
func incrNumB(a int) int { var b int defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB(a) fmt.Println(a, b) // 输出 0 1 } 在defer函数执行之前，会先给返回值赋值，也就是先给栈上的返回值区域先赋值从0变为1，再执行defer函数。
func incrNumB1(a int) (b int) { defer func() { a&#43;&#43; b&#43;&#43; }() a&#43;&#43; b = a return b } func main() { var a = 0 b := incrNumB1(a) fmt."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Secret Room of KyrieXu11
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Go语言原理</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-07-28T23:31:00+08:00">July 28, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="函数调用">函数调用</h1>
<h2 id="栈调用">栈调用</h2>
<p>栈的地址是由上到下从高地址到低地址的。</p>
<p>go语言的函数调用栈从栈基础地址开始，依次填入局部变量、调用的目标函数的返回值和参数。如果函数有多个参数和返回值是从代码顺序的右到左依次压入栈。</p>
<p>返回地址是下一条指令的地址，函数执行完之后会跳转到这里。</p>
<p>并且go语言分配栈空间是一次性分配最大的所需栈空间，因为栈空间在编译期间就可确定，所以可以通过后面要说的<code>morestack</code>进行检测，如果分配的不够则会进行栈增长，另外的开辟一块足够大的栈空间，把原来栈上的数据拷贝到新的空间。</p>
<p><img src="%E6%A0%88.png" alt="image-20220724192021103"></p>
<p>举个例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">incrNumB</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">b</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">incrNumB</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) <span style="color:#75715e">// 输出 0 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在defer函数执行之前，会先给返回值赋值，也就是先给栈上的返回值区域先赋值从0变为1，再执行defer函数。</p>
<p><img src=".%5Cgolang%E8%B0%83%E7%94%A8%E6%A0%88%E5%B8%A7.jpg" alt="golang调用栈帧"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">incrNumB1</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">b</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">incrNumB1</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) <span style="color:#75715e">// 0 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>匿名函数返回值和上面的代码片段的情况不同在于，后者是直接在返回值的地址上做的修改，所以能够改变最后的b值。</p>
<h2 id="寄存器调用">寄存器调用</h2>
<p>在go1.17版本中，函数调用新增了寄存器调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">z</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">d</span>, <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">h</span>, <span style="color:#a6e22e">l</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	println(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	println(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">12</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的代码在调用函数的时候，会把参数都放入寄存器中，一共有<strong>9个</strong>寄存器，如果寄存器不够就的就和原来栈传递参数一样。</p>
<p>返回值也是使用寄存器一起返回的。</p>
<p>那如果是结构体呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RegisterStruct</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int16</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">d</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">g</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">j</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">uint</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这么多字段，会把结构体分为两个部分吗？不会，如果字段太多，就会退回原来的栈调用方式。使用下面的命令可以看见是否使用了寄存器调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>go tool compile -S .<span style="color:#ae81ff">\r</span>egister_call.go
</span></span></code></pre></div><p>如果字段比较少，会使用寄存器调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#a6e22e">.registerFunc</span> <span style="color:#66d9ef">STEXT</span> <span style="color:#66d9ef">nosplit</span> <span style="color:#66d9ef">size</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">136</span> <span style="color:#66d9ef">args</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0x30</span> <span style="color:#66d9ef">locals</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0x38</span> <span style="color:#66d9ef">funcid</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0x0</span> <span style="color:#66d9ef">align</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0x0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#ae81ff">00000</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">TEXT</span>    <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerFunc</span>(<span style="color:#66d9ef">SB</span>), <span style="color:#66d9ef">NOSPLIT</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">ABIInternal</span>, <span style="color:#66d9ef">$56-48</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#ae81ff">00000</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">SUBQ</span>    <span style="color:#66d9ef">$56</span>, <span style="color:#66d9ef">SP</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0004</span> <span style="color:#ae81ff">00004</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVQ</span>    <span style="color:#66d9ef">BP</span>, <span style="color:#ae81ff">48</span>(<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0009</span> <span style="color:#ae81ff">00009</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">LEAQ</span>    <span style="color:#ae81ff">48</span>(<span style="color:#66d9ef">SP</span>), <span style="color:#66d9ef">BP</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000e</span> <span style="color:#ae81ff">00014</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">FUNCDATA</span>        <span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">gclocals</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#ae81ff">1</span><span style="color:#66d9ef">c3ef612cf73709067014b2d0e4ffa70</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000e</span> <span style="color:#ae81ff">00014</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">FUNCDATA</span>        <span style="color:#66d9ef">$1</span>, <span style="color:#66d9ef">gclocals</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#ae81ff">0</span><span style="color:#66d9ef">acea6cc8b9e2fc1c5d67d8ec44c988a</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000e</span> <span style="color:#ae81ff">00014</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">FUNCDATA</span>        <span style="color:#66d9ef">$5</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerFunc.arginfo1</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000e</span> <span style="color:#ae81ff">00014</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVB</span>    <span style="color:#66d9ef">AL</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">64</span>(<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0012</span> <span style="color:#ae81ff">00018</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVW</span>    <span style="color:#66d9ef">BX</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">66</span>(<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0017</span> <span style="color:#ae81ff">00023</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVL</span>    <span style="color:#66d9ef">CX</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">68</span>(<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x001b</span> <span style="color:#ae81ff">00027</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVQ</span>    <span style="color:#66d9ef">DI</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">72</span>(<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0020</span> <span style="color:#ae81ff">00032</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVQ</span>    <span style="color:#66d9ef">SI</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">80</span>(<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0025</span> <span style="color:#ae81ff">00037</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVQ</span>    <span style="color:#66d9ef">R8</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">88</span>(<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x002a</span> <span style="color:#ae81ff">00042</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVQ</span>    <span style="color:#66d9ef">R9</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">96</span>(<span style="color:#66d9ef">SP</span>)
</span></span></code></pre></div><p>而如果字段太多，则会退回栈调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#a6e22e">.registerFunc</span> <span style="color:#66d9ef">STEXT</span> <span style="color:#66d9ef">nosplit</span> <span style="color:#66d9ef">size</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">92</span> <span style="color:#66d9ef">args</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0xc0</span> <span style="color:#66d9ef">locals</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0x8</span> <span style="color:#66d9ef">funcid</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0x0</span> <span style="color:#66d9ef">align</span><span style="color:#960050;background-color:#1e0010">=</span><span style="color:#ae81ff">0x0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#ae81ff">00000</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">TEXT</span>    <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerFunc</span>(<span style="color:#66d9ef">SB</span>), <span style="color:#66d9ef">NOSPLIT</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">ABIInternal</span>, <span style="color:#66d9ef">$8-192</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#ae81ff">00000</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">SUBQ</span>    <span style="color:#66d9ef">$8</span>, <span style="color:#66d9ef">SP</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0004</span> <span style="color:#ae81ff">00004</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">MOVQ</span>    <span style="color:#66d9ef">BP</span>, (<span style="color:#66d9ef">SP</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0008</span> <span style="color:#ae81ff">00008</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">LEAQ</span>    (<span style="color:#66d9ef">SP</span>), <span style="color:#66d9ef">BP</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000c</span> <span style="color:#ae81ff">00012</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">FUNCDATA</span>        <span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">gclocals</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#ae81ff">31</span><span style="color:#66d9ef">a07126bd45886e57ea99e2af0af812</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000c</span> <span style="color:#ae81ff">00012</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">FUNCDATA</span>        <span style="color:#66d9ef">$1</span>, <span style="color:#66d9ef">gclocals</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#ae81ff">69</span><span style="color:#66d9ef">c1753bd5f81501d95132d08af04464</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000c</span> <span style="color:#ae81ff">00012</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">FUNCDATA</span>        <span style="color:#66d9ef">$5</span>, <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerFunc.arginfo1</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x000c</span> <span style="color:#ae81ff">00012</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">LEAQ</span>    <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span>.<span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">r0</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">112</span>(<span style="color:#66d9ef">SP</span>), <span style="color:#66d9ef">DI</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0011</span> <span style="color:#ae81ff">00017</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">PCDATA</span>  <span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">$-2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0011</span> <span style="color:#ae81ff">00017</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">LEAQ</span>    -<span style="color:#ae81ff">32</span>(<span style="color:#66d9ef">DI</span>), <span style="color:#66d9ef">DI</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0015</span> <span style="color:#ae81ff">00021</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">NOP</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0020</span> <span style="color:#ae81ff">00032</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">7</span>)     <span style="color:#66d9ef">DUFFZERO</span>        <span style="color:#66d9ef">$331</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0033</span> <span style="color:#ae81ff">00051</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">8</span>)     <span style="color:#66d9ef">PCDATA</span>  <span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">$-1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0033</span> <span style="color:#ae81ff">00051</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">8</span>)     <span style="color:#66d9ef">LEAQ</span>    <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span>.<span style="color:#960050;background-color:#1e0010">~</span><span style="color:#66d9ef">r0</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">112</span>(<span style="color:#66d9ef">SP</span>), <span style="color:#66d9ef">DI</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0038</span> <span style="color:#ae81ff">00056</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">8</span>)     <span style="color:#66d9ef">LEAQ</span>    <span style="color:#960050;background-color:#1e0010">&#34;&#34;</span><span style="color:#66d9ef">.registerStruct</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">16</span>(<span style="color:#66d9ef">SP</span>), <span style="color:#66d9ef">SI</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x003d</span> <span style="color:#ae81ff">00061</span> (.<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#66d9ef">register_call.go</span>:<span style="color:#ae81ff">8</span>)     <span style="color:#66d9ef">PCDATA</span>  <span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">$-2</span>
</span></span></code></pre></div><h1 id="常用数据结构">常用数据结构</h1>
<h2 id="内存对齐">内存对齐</h2>
<p>内存对齐：cpu从内存获取指令通常是一个字的取的，所以一个变量的内存地址跨越了两个字，存在了两个字之间，cpu想要得到这个变量就得读取两次内存，效率比较低，所以go语言会避免这种情况。</p>
<p>zerobase: 空结构体所指向的地址都是一样的，并且所占用的内存空间为0；这样设计是为了节约内存；使用场景：1.想使用<code>map</code>来做<code>set</code>时，可以将value都设置为空结构体，这样能够节约内存。2.如果使用channel，可以让channel为空结构体的channel，也能节约内存空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">K</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">K</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">K</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>)  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>) <span style="color:#75715e">// 与a变量的地址相同，但是每次编译的结果都不同。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">F</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">K</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int32</span> <span style="color:#75715e">// 如果这里没有一个int32的变量，则下面输出也是zerobase
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">F</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p\n&#34;</span>, <span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">n</span>)) <span style="color:#75715e">// 这里打印的不是zerobase，因为结构体的内存对齐是取成员的最大对齐地址
</span></span></span></code></pre></div><h2 id="结构体内存对齐">结构体内存对齐</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AAAA</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int8</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int16</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">d</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在对齐时，选择类型占用和最大的字节数作为对齐边界，然后按照顺序摆放变量，对齐之后的结构体内存占用要是对齐边界的整数倍，如果不是就需要往上加一点。上面的结构体对齐参数已经是对齐边界 8 的倍数了，所以不需要更改。</p>
<p><img src="%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png" alt=""></p>
<h2 id="关于sizeof的一些疑惑">关于sizeof的一些疑惑</h2>
<p><a href="https://blog.csdn.net/HaoDaWang/article/details/80005072">https://blog.csdn.net/HaoDaWang/article/details/80005072</a></p>
<h2 id="字符串">字符串</h2>
<h3 id="编码方式">编码方式</h3>
<p>字符转换成二进制编码，不同编码方式不能通用，所以有了unicode。</p>
<p>但是如果按照unicode来顺序存储字符的位置的话，可以出现多个不同的划分方式，如</p>
<p><code>00000 00000 00001 00002 0002 0303</code>，可以划分成多个字符，并且划分方式有多种。</p>
<p>如果统一按照最长的字符来编码，每个字符占的位数太多，可能会导致浪费。</p>
<h4 id="utf-8编码方式">utf-8编码方式</h4>
<table>
<thead>
<tr>
<th>编号</th>
<th>编码模板</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 - 127</td>
<td>0???????</td>
</tr>
<tr>
<td>128 - 2047</td>
<td>110????? 10??????</td>
</tr>
<tr>
<td>2048 - 65535</td>
<td>110????? 10?????? 10??????</td>
</tr>
</tbody>
</table>
<p>如将字母<code>e</code>进行编码，e的二进制为101（1100101），在第一个编号范围内，可变成 `0 1100101</p>
<h4 id="数据结构">数据结构</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StringHeader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Data</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Len</span> <span style="color:#66d9ef">int</span>		<span style="color:#75715e">// 数组的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>比如字符串<code>w爱n</code>，len长度为1+3+1=5，data指针指向了字符串开头。</p>
<h2 id="切片">切片</h2>
<h3 id="数据结构-1">数据结构</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">SliceHeader</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Data</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Cap</span> <span style="color:#66d9ef">int</span>	 	<span style="color:#75715e">// 容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Len</span> <span style="color:#66d9ef">int</span>		<span style="color:#75715e">// 当前的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="初始化">初始化</h3>
<p>不论是切片还是其他的，查看初始化的过程可以使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>go build -gcflags -S xxx.go
</span></span></code></pre></div><h4 id="字面量">字面量</h4>
<p>字面量是指创建方式为： arr:=[]int{1, 2, 3}</p>
<p>这种方式在运行时创建了一个大小为3的数组，然后再创建一个slice对象，这个对象的len和cap都是3。伪代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">SliceHeader</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tmp</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span>: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cap</span>: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="make">make</h4>
<p>如果使用make(slice, len, cap)则会将上面的数据结构中的len和cap都置为make参数中的len和cap。</p>
<p>如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ints</span> = make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ints</span> = append(<span style="color:#a6e22e">ints</span>, <span style="color:#ae81ff">3</span>)
</span></span></code></pre></div><p>此时ints[2] = 3，下标为0，1的值都为int类型的默认值0。</p>
<p>data指向数组的开头（只有这里会指向开头），len=2, cap=5</p>
<h4 id="new">new</h4>
<p>如果为new创建的slice，则data会为nil，len=0,cap=0.</p>
<h4 id="从数组中创建">从数组中创建</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">arr</span> = []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> = <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s2</span> = <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">5</span>:]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s3</span> = <span style="color:#a6e22e">arr</span>[:]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d %d\n&#34;</span>, len(<span style="color:#a6e22e">s1</span>), cap(<span style="color:#a6e22e">s1</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d %d\n&#34;</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d %d\n&#34;</span>, len(<span style="color:#a6e22e">s3</span>), cap(<span style="color:#a6e22e">s3</span>))
</span></span></code></pre></div><p>输出的结果是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>3 9  // data指向了1，len=3,cap=9
</span></span><span style="display:flex;"><span>5 5  // data指向了5，len=3,cap=9
</span></span><span style="display:flex;"><span>10 10 // data指向了0 len=10,cap=10
</span></span></code></pre></div><h3 id="追加与扩容">追加与扩容</h3>
<h4 id="追加">追加</h4>
<p>如果不扩容，则调整长度len就行，如果需要扩容则需要创建新的数组，将数据挪过去。</p>
<h4 id="扩容">扩容</h4>
<p><a href="https://juejin.cn/post/7101928883280150558">https://juejin.cn/post/7101928883280150558</a></p>
<p>1.18的扩容机制。</p>
<p>如果新的容量&gt; 2* 老容量，则直接按照新容量进行扩容。否则，如果原来的容量小于256，则新容量为原来的2倍。如果原来容量大于256，则会进入循环，每次容量都增加 （旧容量 + 3*256）/4。</p>
<p><img src="%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99_1.18.png" alt="image-20220723142302761"></p>
<p>扩容都是创建一个新的数组，把原来数组中的元素拷贝到新数组中，并且sliceheader中的指针指向了新的数组。</p>
<h5 id="扩容与函数调用">扩容与函数调用</h5>
<p>可以参考：https://juejin.cn/post/6844904177022271501</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">slice</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">slice</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// f1-before call: slice: [0 1], data addr: 0xc00000a150 variable addr:0xc000004078 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;f1-before call: slice: %v, data addr: %p variable addr:%p \n&#34;</span>, <span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">slice</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>) 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">changeSlice</span>(<span style="color:#a6e22e">slice</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// f1-before call: slice: [0 1], data addr: 0xc00000a150 variable addr:0xc000004078
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;f1-before call: slice: %v, data addr: %p variable addr:%p \n&#34;</span>, <span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">slice</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">slice</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeSlice</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// f2-infunc: func s: [0 1], data addr: 0xc00000a150 variable addr:0xc0000040c0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;f2-infunc: func s: %v, data addr: %p variable addr:%p \n&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">111</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// f2-infunc: func s: [0 111 3 4], data addr: 0xc00000c420 variable addr:0xc0000040c0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;f2-infunc: func s: %v, data addr: %p variable addr:%p \n&#34;</span>, <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>正常的在函数内部更改值<code>s[1] = 111</code>，是能够改变值的（因为函数调用时传递了切片所指向堆的地址），但是由于扩容的机制，s的底层指针指向了一个新的数组，所以导致修改的时候，修改的是扩容之后指向的数组中的值，所以才会出现执行完<code>changeSlice</code>之后，输出的切片还是原来的切片。</p>
<p>总结一下：</p>
<ol>
<li>切片传参的时候，传递的是切片对象的指针（地址）。</li>
<li>添加元素的时候，append会更改sliceheader中的len，但是由于值传递，所以实参不能发现len被修改了。</li>
<li>append的时候，如果扩容了，则在扩容完成之后的切片修改操作，对实参不可见。</li>
</ol>
<h2 id="map">map</h2>
<h3 id="数据结构-2">数据结构</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hmap</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span>     <span style="color:#66d9ef">int</span> <span style="color:#75715e">// kv 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">flags</span>     <span style="color:#66d9ef">uint8</span> <span style="color:#75715e">// 状态，如正在扩容则会更改这个字段，用于标记是等量还是翻倍扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">B</span>         <span style="color:#66d9ef">uint8</span>  <span style="color:#75715e">// buckets长度的2的对数，因为bucket的长度为2的指数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">noverflow</span> <span style="color:#66d9ef">uint16</span> <span style="color:#75715e">// 下一个溢出桶的编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">hash0</span>     <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// hash算法的种子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">buckets</span>    <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// bucket的指针，指向了一个bmap数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">oldbuckets</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 扩容的时候会把这个oldbuckets指向原来的buckets
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nevacuate</span>  <span style="color:#66d9ef">uintptr</span>        <span style="color:#75715e">// 下一个执行驱逐的桶编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">extra</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mapextra</span> <span style="color:#75715e">// 溢出桶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>buckets是指针，指向的数组中的元素的结构类型是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// A bucket for a Go map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">bmap</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// bucketCnt 为 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tophash</span> [<span style="color:#a6e22e">bucketCnt</span>]<span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Followed by bucketCnt keys and then bucketCnt elems.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// NOTE: packing all the keys together and then all the elems together makes the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Followed by an overflow pointer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// kv和overflow的指针会在编译时放入该对象。如果一个bucket要放多个，则overflow指针会指向新加的bmap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果bmap的tophash 8 个都放满了，则会把overflow指针指向新的bucket，指向的对象在下面初始化的时候会创建
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="初始化-1">初始化</h3>
<h4 id="make-1">make</h4>
<ol>
<li>初始化map对象</li>
<li>获取一个hash种子</li>
<li>根据make函数传入的 <code>hint</code> 计算出需要的最小需要的桶的数量</li>
<li>如果桶的数量&gt;0，则创建buckets数组和overflow数组，并且使用hmap对象中的指针指向他们。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// makemap implements Go map creation for make(map[k]v, hint).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If the compiler has determined that the map or the first bucket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// can be created on the stack, h and/or bucket may be non-nil.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If h != nil, the map can be created directly in h.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If h.buckets != nil, bucket pointed to can be used as the first bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makemap</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">maptype</span>, <span style="color:#a6e22e">hint</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hmap</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">hmap</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mem</span>, <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MulUintptr</span>(uintptr(<span style="color:#a6e22e">hint</span>), <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">bucket</span>.<span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">mem</span> &gt; <span style="color:#a6e22e">maxAlloc</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">hint</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 初始化map对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span> = new(<span style="color:#a6e22e">hmap</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算hash种子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">hash0</span> = <span style="color:#a6e22e">fastrand</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// make的时候传递的值，hint &lt; bucketCnt（8）的时候会返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">B</span> <span style="color:#f92672">:=</span> uint8(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">overLoadFactor</span>(<span style="color:#a6e22e">hint</span>, <span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">B</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span> = <span style="color:#a6e22e">B</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果B 不为0，则进行初始化，分配内存空间，但是如果B==0则待会再进行分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">nextOverflow</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bmap</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// nextOverflow指针指向溢出桶，创建一个连续内存空间的buckets数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">buckets</span>, <span style="color:#a6e22e">nextOverflow</span> = <span style="color:#a6e22e">makeBucketArray</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nextOverflow</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span> = new(<span style="color:#a6e22e">mapextra</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">nextOverflow</span> = <span style="color:#a6e22e">nextOverflow</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">h</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>当桶的数量<strong>小于 2^4</strong>时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</li>
<li>当桶的数量<strong>多于 2^4</strong> 时，会额外创建 <strong>2^(B−4)</strong> 个溢出桶；</li>
</ul>
<p>初始化的图示。</p>
<p><img src="makemap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="image-20220723170710885"></p>
<h4 id="字面量-1">字面量</h4>
<h3 id="访问">访问</h3>
<p>总体来看，go中的map底层解决hash冲突是通过拉链法来解决的。</p>
<p>根据key和hash种子计算出hash值，并且取hash值的后B位，得到桶号。</p>
<p>计算桶号的图示过程。</p>
<p><img src="%E8%AE%A1%E7%AE%97%E6%A1%B6%E5%8F%B7.png" alt="image-20220723171410035"></p>
<p>得到桶号之后，访问桶，通过hash值的高8位在bmap中的tophash查询key，然后比对keys是否想要的key，如果key中没有，则去overflow中查询。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">flags</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">hashWriting</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;concurrent map read and map write&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hash</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">hasher</span>(<span style="color:#a6e22e">key</span>, uintptr(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">hash0</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bucketMask</span>(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">bmap</span>)(<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">buckets</span>, (<span style="color:#a6e22e">hash</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>)<span style="color:#f92672">*</span>uintptr(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">bucketsize</span>)))
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果有oldBucktes，先去oldBuckets上查询
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">oldbuckets</span>; <span style="color:#a6e22e">c</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">sameSizeGrow</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">m</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">oldb</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">bmap</span>)(<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">c</span>, (<span style="color:#a6e22e">hash</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>)<span style="color:#f92672">*</span>uintptr(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">bucketsize</span>)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">evacuated</span>(<span style="color:#a6e22e">oldb</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">oldb</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">top</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tophash</span>(<span style="color:#a6e22e">hash</span>)
</span></span></code></pre></div><p>如果在扩容的时候进行读取，当<code>oldbuckets</code>存在时，会先定位到旧桶并且在该桶没有被分流的时候获取kv，如果分流了就会去已经被分流的bucket去获取。</p>
<h3 id="写入">写入</h3>
<p>和读取的流程一样，只不过当oldbuckets存在时，需要进行扩容；并且如果hash冲突到需要新建一个溢出桶，则需要新建溢出桶。</p>
<h3 id="扩容-1">扩容</h3>
<p>扩容的条件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">growing</span>() <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#a6e22e">overLoadFactor</span>(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">count</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">tooManyOverflowBuckets</span>(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">noverflow</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span>)) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">hashGrow</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">h</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">again</span> <span style="color:#75715e">// Growing the table invalidates everything, so try again
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span></code></pre></div><p>负载因子（元素数量/桶数量）&gt;6.5(loadFactorNum/loadFactorDen)或者溢出桶超过了普通桶的个数，则会进行扩容。</p>
<p>扩容的类型分为两种：翻倍扩容和等量扩容</p>
<p>等量扩容：溢出桶太多了。普通桶的数量不翻倍，去创建新的溢出桶，</p>
<p>翻倍扩容：新建普通桶。</p>
<p>等量扩容步骤：</p>
<p>和下面的步骤一样，只不过是不会创建新的buckets，而是会创建新的overflowbucket</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hashGrow</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">maptype</span>, <span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hmap</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 默认翻倍扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">bigger</span> <span style="color:#f92672">:=</span> uint8(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果还没超过负载因子，那就不翻倍了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">overLoadFactor</span>(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">count</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bigger</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">flags</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">sameSizeGrow</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oldbuckets</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">buckets</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建新的bucket和溢出桶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newbuckets</span>, <span style="color:#a6e22e">nextOverflow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">makeBucketArray</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span><span style="color:#f92672">+</span><span style="color:#a6e22e">bigger</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">flags</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">flags</span> <span style="color:#f92672">&amp;^</span> (<span style="color:#a6e22e">iterator</span> | <span style="color:#a6e22e">oldIterator</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">flags</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">iterator</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">flags</span> <span style="color:#f92672">|=</span> <span style="color:#a6e22e">oldIterator</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// commit the grow (atomic wrt gc)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">bigger</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">flags</span> = <span style="color:#a6e22e">flags</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">oldbuckets</span> = <span style="color:#a6e22e">oldbuckets</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">buckets</span> = <span style="color:#a6e22e">newbuckets</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">nevacuate</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">noverflow</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">overflow</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Promote current overflow buckets to the old generation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">oldoverflow</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;oldoverflow is not nil&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">oldoverflow</span> = <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">overflow</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">overflow</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nextOverflow</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span> = new(<span style="color:#a6e22e">mapextra</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">nextOverflow</span> = <span style="color:#a6e22e">nextOverflow</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// the actual copying of the hash table data is done incrementally
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// by growWork() and evacuate().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>翻倍扩容步骤</p>
<ol>
<li>
<p>判断是否正在处于扩容阶段，避免二次扩容。</p>
</li>
<li>
<p>新建buckets，并进行翻倍，将oldbuckets指针指向原来的bucket，buckets指针指向新建的bucket。并且原来的nextOverflow的指针也指向新的overflowbucket，而oldoverflow指向原来的overflowbucket。（runtime.hashgrow()）</p>
</li>
<li>
<p>翻倍扩容迁移的过程是在进行数据操作（写操作）渐变式的迁移的，当要去操作一个kv的时候，不光需要操作一个kv，而是要迁移整个bucket。迁移会遇见一个问题，由于buckets数量变化，那么在迁移到目标bucket的时候，该怎么迁移。由于只翻了一倍，原来计算桶号的hash值和当前的hash值的最后几位只差了一位，所以当新桶号的高位为0则桶号不变，高位为1则会迁移到新桶号的桶中。(runtime.growWork())</p>
</li>
<li>
<p>当迁移结束，则进行oldBuckets和oldOverflow的释放。</p>
</li>
</ol>
<h2 id="syncmap">sync.Map</h2>
<p>原生的map在多协程环境下会直接抛出panic。</p>
<h3 id="数据结构-3">数据结构</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">Mutex</span> <span style="color:#75715e">// 并发安全的所以需要锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">read</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Value</span> <span style="color:#75715e">// readOnly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dirty</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">any</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">entry</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">misses</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">readOnly</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>       <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">any</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">entry</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">amended</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// true if the dirty map contains some key not in m.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="原理概述">原理概述</h3>
<ol>
<li>通过read和dirty两个字段做了读写分离，新加的数据放在了dirty里面，read存的数据都是只读的。</li>
<li>读取的时候先查询read，然后再查询dirty；写入的时候只写入dirty。</li>
<li>读取read不需要加锁，而读写dirty的时候需要加锁。</li>
<li>引入了misses字段，统计在read中找不到数据的情况，加锁读取dirty的次数，如果misses的大小等于dirty的长度，则会把dirty上升到read。</li>
</ol>
<h3 id="源码">源码</h3>
<p>读取：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">key</span> <span style="color:#a6e22e">any</span>) (<span style="color:#a6e22e">value</span> <span style="color:#a6e22e">any</span>, <span style="color:#a6e22e">ok</span> <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">read</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">Load</span>().(<span style="color:#a6e22e">readOnly</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果raed中没有，但是dirty有，amended表示，read没有，dirty有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">amended</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 再获取一下避免在获取锁的时候block了，其他的线程把dirty上升到read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">read</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">Load</span>().(<span style="color:#a6e22e">readOnly</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">amended</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirty</span>[<span style="color:#a6e22e">key</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">missLocked</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">load</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">missLocked</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">misses</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">misses</span> &lt; len(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirty</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 上升dirty到read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">readOnly</span>{<span style="color:#a6e22e">m</span>: <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirty</span>})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirty</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">misses</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>写入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> <span style="color:#a6e22e">any</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果read中有，优先把数据更新到read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">read</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">Load</span>().(<span style="color:#a6e22e">readOnly</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">tryStore</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">value</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">read</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">Load</span>().(<span style="color:#a6e22e">readOnly</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在read中找到了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// e在dirty中删掉了但是在read中有，说明dirty不是空map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">unexpungeLocked</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 写入dirty
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirty</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">e</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">storeLocked</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果read中没有，在dirty中找到了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirty</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">storeLocked</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// dirty 和 read都没有，read需要添加数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">amended</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// We&#39;re adding the first new key to the dirty map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// Make sure it is allocated and mark the read-only map as incomplete.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirtyLocked</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">readOnly</span>{<span style="color:#a6e22e">m</span>: <span style="color:#a6e22e">read</span>.<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">amended</span>: <span style="color:#66d9ef">true</span>})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">dirty</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">newEntry</span>(<span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="接口指针结构体">接口、指针、结构体</h1>
<h2 id="类型系统">类型系统</h2>
<p>每个类型，如int、int64、int32、string、slice、map都会有类型描述信息，这个就是类型元数据，并且每个类型的类型元数据都是全局唯一的。这些信息都被放到了<code>_type</code>结构体中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">_type</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">size</span>       <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 类型占用的空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ptrdata</span>    <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// size of memory prefix holding all pointers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">hash</span>       <span style="color:#66d9ef">uint32</span>  <span style="color:#75715e">// 可以判断两个对象的类型是否相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tflag</span>      <span style="color:#a6e22e">tflag</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">align</span>      <span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fieldAlign</span> <span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">kind</span>       <span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// function for comparing objects of this type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (ptr to object A, ptr to object B) -&gt; ==?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">equal</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// gcdata stores the GC type data for the garbage collector.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// If the KindGCProg bit is set in kind, gcdata is a GC program.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gcdata</span>    <span style="color:#f92672">*</span><span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">str</span>       <span style="color:#a6e22e">nameOff</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ptrToThis</span> <span style="color:#a6e22e">typeOff</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyStruct</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">o</span> <span style="color:#a6e22e">MyStruct</span>) <span style="color:#a6e22e">Len</span>() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">o</span> <span style="color:#a6e22e">MyStruct</span>) <span style="color:#a6e22e">Cap</span>() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span> }
</span></span></code></pre></div><p>如果是自定义类型的话，如上所示，会在后面加上一个<code>uncommontype</code>结构体。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">u</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_type</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">u</span> <span style="color:#a6e22e">uncommontype</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">uncommontype</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pkgpath</span> <span style="color:#a6e22e">nameOff</span> <span style="color:#75715e">// 包路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mcount</span>  <span style="color:#66d9ef">uint16</span> <span style="color:#75715e">// 方法的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">xcount</span>  <span style="color:#66d9ef">uint16</span> <span style="color:#75715e">// 可导出的方法的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">moff</span>    <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// offset from this uncommontype to [mcount]method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_</span>       <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>moff</code>表示，自定义的结构体中的方法相对于此<code>uncommontype</code>偏移了多少个字节。用最上面的自定义的结构体举个例子，通过这个变量就可以找到Len和Cap两个方法。</p>
<h2 id="接口">接口</h2>
<h3 id="数据结构-4">数据结构</h3>
<p>空接口有专门的数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">eface</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_type</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span>  <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>_type类型在上面已经给出。</p>
<p>有方法的接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iface</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tab</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">itab</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">itab</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>  <span style="color:#75715e">//  接口类型元数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_type</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span> <span style="color:#75715e">// 实际类型元数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">hash</span>  <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// 这里的hash，当想把某个接口转换成具体类型的时候，可以用这个字段快速判断两个类型是否相等，这个在类型断言中会用到。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_</span>     [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fun</span>   [<span style="color:#ae81ff">1</span>]<span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 实现的方法地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">interfacetype</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">interfacetype</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">typ</span>     <span style="color:#a6e22e">_type</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pkgpath</span> <span style="color:#a6e22e">name</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mhdr</span>    []<span style="color:#a6e22e">imethod</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>每一个 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 都占 <strong>32</strong> 字节，</p>
<p><strong>Go 语言的接口类型不是任意类型</strong>，下面的例子说明在调用NilOrNot函数的时候发生了类型转换，这说明interface不是任意类型。</p>
<p>为什么传进该函数的不是nil？因为在转换的时候，空接口对象不仅包含转换前的变量（这个为nil），还包含转换前的类型。</p>
<p>也就是上面的eface中的<code>_type</code>不为nil，data指向的指针为空，所以转换之后的interface不为nil。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TestStruct</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NilOrNot</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TestStruct</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)    <span style="color:#75715e">// #=&gt; true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">NilOrNot</span>(<span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// #=&gt; false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)    <span style="color:#75715e">// #=&gt; true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">NilOrNot</span>(<span style="color:#a6e22e">i</span>)) <span style="color:#75715e">// #=&gt; true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="类型断言">类型断言</h2>
<p>空接口是判断<code>_type</code>是否为断言的类型元数据，因为类型元数据是全局唯一的。</p>
<p>非空接口比较<code>itab</code>中的hash值和断言类型元数据中的hash值是否相等</p>
<h3 id="方法">方法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">InterA</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Fu</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">InterB</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Fu</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StruA</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Gu</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">StruA</span>) <span style="color:#a6e22e">Fu</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Gu</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">InterA</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">StruA</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>InterA</code>可以使用<code>StruA</code>的指针来初始化，也可以使用<code>StruA</code>的值来初始化，但是<code>StruA</code>并没有手动实现<code>InterA</code>指针方法<code>Fu</code>，这个是因为编译器在编译的时候，会自动生成一个指针类型的<code>Fu</code>方法，所以变量<code>c</code>才能使用指针来进行初始化。但是如果使用指针实现的接口方法，编译器并不会自动生成一个值实现的方法。</p>
<p><img src="struct_%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96.png" alt="image-20220723231524293"></p>
<h1 id="defer">defer</h1>
<p>defer的原理就是把defer的函数封装成一个对象放入当前协程的defer链表表头（头插法），这样才会有后声明的defer先执行。</p>
<h1 id="并发编程">并发编程</h1>
<h2 id="协程">协程</h2>
<h3 id="本质">本质</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">g</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stack</span>       <span style="color:#a6e22e">stack</span>   <span style="color:#75715e">// offset known to runtime/cgo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stackguard0</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// offset known to liblink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stackguard1</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// offset known to liblink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_panic</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">_panic</span> <span style="color:#75715e">// innermost panic - offset known to liblink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_defer</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">_defer</span> <span style="color:#75715e">// innermost defer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">m</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>      <span style="color:#75715e">// current m; offset known to arm liblink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sched</span>     <span style="color:#a6e22e">gobuf</span> <span style="color:#75715e">// 协程运行的现场
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">syscallsp</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// if status==Gsyscall, syscallsp = sched.sp to use during gc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">syscallpc</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// if status==Gsyscall, syscallpc = sched.pc to use during gc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stktopsp</span>  <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// expected sp at top of stack, to check in traceback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">param</span>        <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">atomicstatus</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stackLock</span>    <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// sigprof/scang lock; TODO: fold in to atomicstatus
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">goid</span>         <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">schedlink</span>    <span style="color:#a6e22e">guintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waitsince</span>    <span style="color:#66d9ef">int64</span>      <span style="color:#75715e">// approx time when the g become blocked
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">waitreason</span>   <span style="color:#a6e22e">waitReason</span> <span style="color:#75715e">// if status==Gwaiting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">preempt</span>       <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// preemption signal, duplicates stackguard0 = stackpreempt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">preemptStop</span>   <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// transition to _Gpreempted on preemption; otherwise, just deschedule
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">preemptShrink</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// shrink stack at synchronous safe point
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">asyncSafePoint</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">paniconfault</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// panic (instead of crash) on unexpected fault address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gcscandone</span>   <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// g has scanned stack; protected by _Gscan bit in status
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">throwsplit</span>   <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// must not split stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">activeStackChans</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">parkingOnChan</span> <span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">raceignore</span>     <span style="color:#66d9ef">int8</span>     <span style="color:#75715e">// ignore race detection events
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sysblocktraced</span> <span style="color:#66d9ef">bool</span>     <span style="color:#75715e">// StartTrace has emitted EvGoInSyscall about this goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tracking</span>       <span style="color:#66d9ef">bool</span>     <span style="color:#75715e">// whether we&#39;re tracking this G for sched latency statistics
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">trackingSeq</span>    <span style="color:#66d9ef">uint8</span>    <span style="color:#75715e">// used to decide whether to track this G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runnableStamp</span>  <span style="color:#66d9ef">int64</span>    <span style="color:#75715e">// timestamp of when the G last became runnable, only used when tracking
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runnableTime</span>   <span style="color:#66d9ef">int64</span>    <span style="color:#75715e">// the amount of time spent runnable, cleared when running, only used when tracking
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sysexitticks</span>   <span style="color:#66d9ef">int64</span>    <span style="color:#75715e">// cputicks when syscall has returned (for tracing)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">traceseq</span>       <span style="color:#66d9ef">uint64</span>   <span style="color:#75715e">// trace event sequencer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tracelastp</span>     <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// last P emitted an event for this goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lockedm</span>        <span style="color:#a6e22e">muintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sig</span>            <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">writebuf</span>       []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sigcode0</span>       <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sigcode1</span>       <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sigpc</span>          <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gopc</span>           <span style="color:#66d9ef">uintptr</span>         <span style="color:#75715e">// pc of go statement that created this goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ancestors</span>      <span style="color:#f92672">*</span>[]<span style="color:#a6e22e">ancestorInfo</span> <span style="color:#75715e">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">startpc</span>        <span style="color:#66d9ef">uintptr</span>         <span style="color:#75715e">// pc of goroutine function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">racectx</span>        <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waiting</span>        <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>         <span style="color:#75715e">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cgoCtxt</span>        []<span style="color:#66d9ef">uintptr</span>      <span style="color:#75715e">// cgo traceback context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">labels</span>         <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// profiler labels
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">timer</span>          <span style="color:#f92672">*</span><span style="color:#a6e22e">timer</span>         <span style="color:#75715e">// cached timer for time.Sleep
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">selectDone</span>     <span style="color:#66d9ef">uint32</span>         <span style="color:#75715e">// are we participating in a select and did someone win the race?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gcAssistBytes</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>比较重要的几个属性：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 上面g中属性名称为stack的结构体的stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">stack</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lo</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 低位指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">hi</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 高位指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 上面g中属性名称为sched的结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">gobuf</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sp</span>   <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 栈指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pc</span>   <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 程序计数器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">g</span>    <span style="color:#a6e22e">guintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctxt</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ret</span>  <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lr</span>   <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bp</span>   <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// for framepointer-enabled architectures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">atomicstatus</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// 协程的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">goid</span>         <span style="color:#66d9ef">int64</span> <span style="color:#75715e">// 协程的id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">m</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>      <span style="color:#75715e">// go语言中线程的描述
</span></span></span></code></pre></div><p>协程状态有下面几种：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_Gidle</span> = <span style="color:#66d9ef">iota</span> <span style="color:#75715e">// 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Grunnable</span> <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Grunning</span> <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gsyscall</span> <span style="color:#75715e">// 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gwaiting</span> <span style="color:#75715e">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gmoribund_unused</span> <span style="color:#75715e">// 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gdead</span> <span style="color:#75715e">// 6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Genqueue_unused</span> <span style="color:#75715e">// 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gcopystack</span> <span style="color:#75715e">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gpreempted</span> <span style="color:#75715e">// 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gscan</span>          = <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_Gscanrunnable</span>  = <span style="color:#a6e22e">_Gscan</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_Grunnable</span>  <span style="color:#75715e">// 0x1001
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gscanrunning</span>   = <span style="color:#a6e22e">_Gscan</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_Grunning</span>   <span style="color:#75715e">// 0x1002
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gscansyscall</span>   = <span style="color:#a6e22e">_Gscan</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_Gsyscall</span>   <span style="color:#75715e">// 0x1003
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gscanwaiting</span>   = <span style="color:#a6e22e">_Gscan</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_Gwaiting</span>   <span style="color:#75715e">// 0x1004
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_Gscanpreempted</span> = <span style="color:#a6e22e">_Gscan</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_Gpreempted</span> <span style="color:#75715e">// 0x1009
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Gidle</code></td>
<td>刚刚被分配并且还没有被初始化</td>
</tr>
<tr>
<td><code>_Grunnable</code></td>
<td>没有执行代码，没有栈的所有权，存储在运行队列中</td>
</tr>
<tr>
<td><code>_Grunning</code></td>
<td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td>
</tr>
<tr>
<td><code>_Gsyscall</code></td>
<td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td>
</tr>
<tr>
<td><code>_Gwaiting</code></td>
<td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td>
</tr>
<tr>
<td><code>_Gdead</code></td>
<td>没有被使用，没有执行代码，可能有分配的栈</td>
</tr>
<tr>
<td><code>_Gcopystack</code></td>
<td>栈正在被拷贝，没有执行代码，不在运行队列上</td>
</tr>
<tr>
<td><code>_Gpreempted</code></td>
<td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td>
</tr>
<tr>
<td><code>_Gscan</code></td>
<td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td>
</tr>
</tbody>
</table>
<p>线程在go中的体现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">g0</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>     <span style="color:#75715e">// g0 是持有调度栈的 Goroutine，主协程对应的g
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">morebuf</span> <span style="color:#a6e22e">gobuf</span>  <span style="color:#75715e">// gobuf arg to morestack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">divmod</span>  <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// div/mod denominator for arm - known to liblink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_</span>       <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// align next field to 8 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Fields not known to debuggers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">procid</span>        <span style="color:#66d9ef">uint64</span>            <span style="color:#75715e">// for debuggers, but offset not hard-coded
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gsignal</span>       <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>                <span style="color:#75715e">// signal-handling g
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">goSigStack</span>    <span style="color:#a6e22e">gsignalStack</span>      <span style="color:#75715e">// Go-allocated signal handling stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sigmask</span>       <span style="color:#a6e22e">sigset</span>            <span style="color:#75715e">// storage for saved signal mask
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tls</span>           [<span style="color:#a6e22e">tlsSlots</span>]<span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// thread-local storage (for x86 extern register)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mstartfn</span>      <span style="color:#66d9ef">func</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">curg</span>          <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>       <span style="color:#75715e">// curg 是在当前线程上运行的用户 Goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">caughtsig</span>     <span style="color:#a6e22e">guintptr</span> <span style="color:#75715e">// goroutine running during fatal signal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">p</span>             <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// gmp模型中的p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nextp</span>         <span style="color:#a6e22e">puintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">oldp</span>          <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// the p that was attached before executing a syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">id</span>            <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mallocing</span>     <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">throwing</span>      <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">preemptoff</span>    <span style="color:#66d9ef">string</span> <span style="color:#75715e">// if != &#34;&#34;, keep curg running on this m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">locks</span>         <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dying</span>         <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">profilehz</span>     <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spinning</span>      <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// m is out of work and is actively looking for work
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">blocked</span>       <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// m is blocked on a note
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newSigstack</span>   <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// minit on C thread called sigaltstack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">printlock</span>     <span style="color:#66d9ef">int8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">incgo</span>         <span style="color:#66d9ef">bool</span>   <span style="color:#75715e">// m is executing a cgo call
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">freeWait</span>      <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// if == 0, safe to free g0 and delete m (atomic)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fastrand</span>      <span style="color:#66d9ef">uint64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">needextram</span>    <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">traceback</span>     <span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ncgocall</span>      <span style="color:#66d9ef">uint64</span>      <span style="color:#75715e">// number of cgo calls in total
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ncgo</span>          <span style="color:#66d9ef">int32</span>       <span style="color:#75715e">// number of cgo calls currently in progress
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cgoCallersUse</span> <span style="color:#66d9ef">uint32</span>      <span style="color:#75715e">// if non-zero, cgoCallers in use temporarily
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cgoCallers</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">cgoCallers</span> <span style="color:#75715e">// cgo traceback if crashing in cgo call
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">park</span>          <span style="color:#a6e22e">note</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">alllink</span>       <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span> <span style="color:#75715e">// on allm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">schedlink</span>     <span style="color:#a6e22e">muintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lockedg</span>       <span style="color:#a6e22e">guintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">createstack</span>   [<span style="color:#ae81ff">32</span>]<span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// stack that created this thread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lockedExt</span>     <span style="color:#66d9ef">uint32</span>      <span style="color:#75715e">// tracking for external LockOSThread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lockedInt</span>     <span style="color:#66d9ef">uint32</span>      <span style="color:#75715e">// tracking for internal lockOSThread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nextwaitm</span>     <span style="color:#a6e22e">muintptr</span>    <span style="color:#75715e">// next m waiting for lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">waitunlockf</span>   <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waitlock</span>      <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waittraceev</span>   <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waittraceskip</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">startingtrace</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">syscalltick</span>   <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">freelink</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span> <span style="color:#75715e">// on sched.freem
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// these are here because they are too large to be on the stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// of low-level NOSPLIT functions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">libcall</span>   <span style="color:#a6e22e">libcall</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">libcallpc</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// for cpu profiler
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">libcallsp</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">libcallg</span>  <span style="color:#a6e22e">guintptr</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">preemptGen</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">signalPending</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dlogPerM</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mOS</span> <span style="color:#75715e">// 操作系统线程信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Up to 10 locks held by this m, maintained by the lock ranking code.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">locksHeldLen</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">locksHeld</span>    [<span style="color:#ae81ff">10</span>]<span style="color:#a6e22e">heldLockInfo</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>线程的状态只有：running和stop两种状态，如果m没有g可以运行了，就会陷入spinning状态，等待调度程序给一个g运行，如果找不到(<code>findrunnable()</code>函数没获取到g)，会stopm。</p>
<p>调度器（<strong>部分属性</strong>）：</p>
<p>调度器中存放了全局的goroutine队列，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">schedt</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// accessed atomically. keep at top to ensure alignment on 32-bit systems.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">goidgen</span>   <span style="color:#66d9ef">uint64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lastpoll</span>  <span style="color:#66d9ef">uint64</span> <span style="color:#75715e">// time of last network poll, 0 if currently polling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pollUntil</span> <span style="color:#66d9ef">uint64</span> <span style="color:#75715e">// time to which current poll is sleeping
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">midle</span>        <span style="color:#a6e22e">muintptr</span> <span style="color:#75715e">// 空闲的m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pidle</span>      <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// 空闲的p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">npidle</span>     <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nmspinning</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Global runnable queue.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runq</span>     <span style="color:#a6e22e">gQueue</span> <span style="color:#75715e">// 全局的协程队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runqsize</span> <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Central cache of sudog structs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sudoglock</span>  <span style="color:#a6e22e">mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sudogcache</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Central pool of available defer structs.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">deferlock</span> <span style="color:#a6e22e">mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">deferpool</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_defer</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">freem</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gcwaiting</span>  <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// gc is waiting to run
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stopwait</span>   <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stopnote</span>   <span style="color:#a6e22e">note</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sysmonwait</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sysmonnote</span> <span style="color:#a6e22e">note</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">safePointFn</span>   <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">safePointWait</span> <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">safePointNote</span> <span style="color:#a6e22e">note</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">profilehz</span> <span style="color:#66d9ef">int32</span> <span style="color:#75715e">// cpu profiling rate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">procresizetime</span> <span style="color:#66d9ef">int64</span> <span style="color:#75715e">// nanotime() of last change to gomaxprocs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">totaltime</span>      <span style="color:#66d9ef">int64</span> <span style="color:#75715e">// ∫gomaxprocs dt up to procresizetime
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="程序引导启动做了什么">程序引导启动做了什么</h3>
<p><a href="https://juejin.cn/post/6942509882281033764">https://juejin.cn/post/6942509882281033764</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">TEXT</span> <span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">rt0_go</span>(<span style="color:#66d9ef">SB</span>),<span style="color:#66d9ef">NOSPLIT</span><span style="color:#960050;background-color:#1e0010">|</span><span style="color:#66d9ef">TOPFRAME</span>,<span style="color:#66d9ef">$0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">copy</span> <span style="color:#66d9ef">arguments</span> <span style="color:#66d9ef">forward</span> <span style="color:#66d9ef">on</span> <span style="color:#66d9ef">an</span> <span style="color:#66d9ef">even</span> <span style="color:#66d9ef">stack</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">create</span> <span style="color:#66d9ef">istack</span> <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">the</span> <span style="color:#66d9ef">given</span> (<span style="color:#66d9ef">operating</span> <span style="color:#66d9ef">system</span>) <span style="color:#66d9ef">stack.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">_cgo_init</span> <span style="color:#66d9ef">may</span> <span style="color:#66d9ef">update</span> <span style="color:#66d9ef">stackguard.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">初始化</span><span style="color:#a6e22e">g0的执行栈</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">$runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">g0</span>(<span style="color:#66d9ef">SB</span>), <span style="color:#66d9ef">DI</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">find</span> <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">information</span> <span style="color:#66d9ef">about</span> <span style="color:#66d9ef">the</span> <span style="color:#66d9ef">processor</span> <span style="color:#66d9ef">we</span><span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">re</span> <span style="color:#66d9ef">on</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">set</span> <span style="color:#66d9ef">the</span> <span style="color:#66d9ef">per-goroutine</span> <span style="color:#66d9ef">and</span> <span style="color:#66d9ef">per-mach</span> <span style="color:#960050;background-color:#1e0010">&#34;</span><span style="color:#66d9ef">registers</span><span style="color:#960050;background-color:#1e0010">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">get_tls</span>(<span style="color:#66d9ef">BX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">g0</span>(<span style="color:#66d9ef">SB</span>), <span style="color:#66d9ef">CX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">CX</span>, <span style="color:#66d9ef">g</span>(<span style="color:#66d9ef">BX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">m0</span>(<span style="color:#66d9ef">SB</span>), <span style="color:#66d9ef">AX</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">设置引用关系</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">save</span> <span style="color:#66d9ef">m-</span><span style="color:#960050;background-color:#1e0010">&gt;</span><span style="color:#66d9ef">g0</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#66d9ef">g0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">CX</span>, <span style="color:#66d9ef">m_g0</span>(<span style="color:#66d9ef">AX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">save</span> <span style="color:#66d9ef">m0</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">g0-</span><span style="color:#960050;background-color:#1e0010">&gt;</span><span style="color:#66d9ef">m</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">AX</span>, <span style="color:#66d9ef">g_m</span>(<span style="color:#66d9ef">CX</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CLD</span>				<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">convention</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">D</span> <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">always</span> <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">cleared</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">check</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">args</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">osinit</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">初始化调度</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">schedinit</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#a6e22e">create</span> <span style="color:#66d9ef">a</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">goroutine</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">start</span> <span style="color:#66d9ef">program</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">$runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">mainPC</span>(<span style="color:#66d9ef">SB</span>), <span style="color:#66d9ef">AX</span>		<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">entry</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">PUSHQ</span>	<span style="color:#66d9ef">AX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">创建一个</span><span style="color:#a6e22e">goroutine启动程序</span><span style="color:#960050;background-color:#1e0010">，不是</span><span style="color:#66d9ef">g0</span>,<span style="color:#960050;background-color:#1e0010">是</span><span style="color:#66d9ef">main-goroutine</span><span style="color:#960050;background-color:#1e0010">，启动</span><span style="color:#66d9ef">runtime.main</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">newproc</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">POPQ</span>	<span style="color:#66d9ef">AX</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">启动线程</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">mstart</span>(<span style="color:#66d9ef">SB</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#66d9ef">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#66d9ef">abort</span>(<span style="color:#66d9ef">SB</span>)	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">mstart</span> <span style="color:#66d9ef">should</span> <span style="color:#66d9ef">never</span> <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RET</span>
</span></span></code></pre></div><p>两个主要的全局变量：</p>
<p><code>m0</code>：主线程对应的m，m0和其他的m的数据结构没有任何区别，在上面的汇编代码中可以看见m0是在go程序启动时，用汇编赋值的，而后续的其他m都是通过<code>mstart</code>创建的。</p>
<p><strong><code>g0</code></strong>：负责在每个正在运行的线程上<strong>调度和管理</strong> goroutine的特殊的协程，与<code>m0</code>一样，其赋值是在进程启动时进行赋值的，在<code>g0</code>上分配的栈是系统栈，调度函数是在<code>g0</code>上运行的， <strong>每一个 m 都只有一个 <code>g0</code></strong>（仅此只有一个 <code>g0</code>），全局变量的<code>g0</code> 是 <code>m0</code> 的 <code>g0</code>。<code>main goroutine</code>是运行runtime.main的协程，是在汇编代码创建并且启动的协程，在runtim.main中的<code>getg()</code>获取的就是该协程。</p>
<p><a href="https://medium.com/a-journey-with-go/go-g0-special-goroutine-8c778c6704d8">G0的作用</a>：其实就是运行schedule()，m上的g变为_GWaiting了之后，会切换到g0执行调度寻找g。</p>
<p>总结：</p>
<ol>
<li>初始化g0栈。</li>
<li>设置m0和g0互引用的关系。</li>
<li>调用schedinit初始化调度。</li>
<li>启动main-goroutine，调用runtime.main。</li>
<li>启动一个线程用来调度。</li>
</ol>
<h3 id="创建新协程经历了什么">创建新协程经历了什么</h3>
<p>前置知识：<a href="#%E8%B0%83%E7%94%A8%E6%A0%88">调用栈</a></p>
<p>几个全局变量</p>
<p><code>g0</code>：负责在每个正在运行的线程上调度和管理 goroutine的特殊的协程，每一个 m 都只有一个 g0（仅此只有一个 g0），全局变量的g0 是 m0的g0。</p>
<p><code>m0</code>: 主线程对应的m，一个进程只会有一个m0，m0负责执行初始化操作和启动第一个 g (g0).</p>
<p><code>allgs</code>：所有的协程，包括状态为<code>_Gdead</code>，所以不会减小。</p>
<p><code>sched</code>：记录了所有状态为<code>_Grunnable</code>的协程的<code>runq</code>，并且记录了空闲的p和空闲的m。</p>
<p><code>gfree</code>：可以复用的g（status=_GDead）。</p>
<p>在1.18下调用newproc函数需要传递一个参数，那就是函数的指针。所以在函数调用栈中会传递函数的指针。</p>
<p>而调用Foo函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">Foo</span>(<span style="color:#e6db74">&#34;Bar&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newproc</span>(<span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getcallerpc</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">newg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newproc1</span>(<span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">pc</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">_p_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">runqput</span>(<span style="color:#a6e22e">_p_</span>, <span style="color:#a6e22e">newg</span>, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mainStarted</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">wakep</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>newproc的步骤：</p>
<ol>
<li>
<p>获取当前的g。</p>
</li>
<li>
<p>获取调用结束后的pc，就是调用newproc函数结束后，在栈中的返回地址。</p>
</li>
<li>
<p>切换成g0栈调用newproc1函数。切换成g0栈的目的是g0栈使用的是主线程的栈，足够大不会有栈溢出的风险。</p>
</li>
<li>
<p>将新建的g放入分配的p的本地runq中。</p>
</li>
</ol>
<p>newproc1函数太长了，只放部分关键步骤：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newproc1</span>(<span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>, <span style="color:#a6e22e">callergp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">callerpc</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取当前g，这里的g就是g0,newproc是切换到g0栈上运行的本函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">acquirem</span>() <span style="color:#75715e">// 抢占m，并且不让m被抢占，因为局部变量会保存当前_p_，如果别的m把当前的p抢走了会有问题。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取g，如果没获取到就新建一个并且把状态改成_Gdead，添加到allgs中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 此时newg有自己的协程栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gfget</span>(<span style="color:#a6e22e">_p_</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newg</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">newg</span> = <span style="color:#a6e22e">malg</span>(<span style="color:#a6e22e">_StackMin</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gidle</span>, <span style="color:#a6e22e">_Gdead</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">allgadd</span>(<span style="color:#a6e22e">newg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">readgstatus</span>(<span style="color:#a6e22e">newg</span>) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_Gdead</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;newproc1: new g is not Gdead&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stktopsp</span> = <span style="color:#a6e22e">sp</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将调度器的pc指向goexit函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">pc</span> = <span style="color:#a6e22e">abi</span>.<span style="color:#a6e22e">FuncPCABI0</span>(<span style="color:#a6e22e">goexit</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PCQuantum</span> 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">guintptr</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">newg</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把pc指向了目标协程函数的地址，就是指令跳转到目标函数栈帧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 等调度开始了就开始执行目标函数，执行完了就会调用上面压入栈的goexit函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gostartcallfn</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>, <span style="color:#a6e22e">fn</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 更改状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gdead</span>, <span style="color:#a6e22e">_Grunnable</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gcController</span>.<span style="color:#a6e22e">addScannableStack</span>(<span style="color:#a6e22e">_p_</span>, int64(<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span><span style="color:#f92672">-</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 释放抢占的m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>) 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gostartcall</span>(<span style="color:#a6e22e">buf</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gobuf</span>, <span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">ctxt</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">sp</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">sp</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把sp指针指向了goexit函数地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">pc</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把pc指向了函数的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">pc</span> = uintptr(<span style="color:#a6e22e">fn</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">ctxt</span> = <span style="color:#a6e22e">ctxt</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>总结上面的步骤：</p>
<ol>
<li>抢占m，获取当前的g（g0，因为切换到了g0栈上），禁止m被抢占。</li>
<li>从<code>gfree</code>获取g，如果没获取到就新建一个并且把状态改成_Gdead，并且如果newg没有栈，就新建一个<strong>2kb</strong>的栈，把g添加到allgs中</li>
<li>将调度器的sp指针指向goexit函数，这样在协程调度回来运行完成之后才会自动调用goexit()函数（因为这里存放的相当于是return addr,是下一条指令的地址），具体可以看https://cloud.tencent.com/developer/article/1836273</li>
<li>把g的状态从_GDead改成 _GRunnable，从而能放到当前p的本地队列。</li>
<li>释放m。</li>
</ol>
<p><img src=".%5C%E5%8D%8F%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A0%88.png" alt=""></p>
<h2 id="调度">调度</h2>
<h3 id="0x的调度器">0.x的调度器</h3>
<ol>
<li>获取调度的全局锁。</li>
<li>从**全局队列（此时就只有一个全局队列）**中获取可执行的go协程。</li>
<li>修改线程<code>m</code>中执行的协程。</li>
<li>运行协程。</li>
</ol>
<p>这种方式是单线程取执行的，效率比较低。</p>
<h3 id="10的调度器">1.0的调度器</h3>
<p>这个时候调度器已经发展成多线程调度器，多线程就是多个线程共享一个协程队列，获取协程运行，但是多线程调度器有许多问题：</p>
<ol>
<li>协程队列会有并发问题，多个线程争抢锁消耗严重。</li>
<li>每个线程都需要处理内存缓存，导致大量的内存占用并影响数据局部性；</li>
</ol>
<h3 id="任务窃取调度器">任务窃取调度器</h3>
<p>在上面的多线程的调度器基础上引入了：</p>
<ol>
<li>在当前的 G-M 模型中引入了处理器 P，增加中间层；</li>
<li>在处理器 P 的基础上实现基于工作窃取的调度器；</li>
</ol>
<p>p的结构体(<strong>只保留了部分重要的属性</strong>)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">id</span>          <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">status</span>      <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>           <span style="color:#a6e22e">muintptr</span>  <span style="color:#75715e">// 线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runqhead</span> <span style="color:#66d9ef">uint32</span>		<span style="color:#75715e">// 指向协程队列的队首指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runqtail</span> <span style="color:#66d9ef">uint32</span>		<span style="color:#75715e">// 指向协程队列的队尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runq</span>     [<span style="color:#ae81ff">256</span>]<span style="color:#a6e22e">guintptr</span>	<span style="color:#75715e">// 当前线程的协程队列，最大256个协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runnext</span> <span style="color:#a6e22e">guintptr</span>	<span style="color:#75715e">// 下一个可以执行的协程指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mcache</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mcache</span>  <span style="color:#75715e">// 堆内存的线程级别的分配器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>p也有几种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Pidle</code></td>
<td>处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</td>
</tr>
<tr>
<td><code>_Prunning</code></td>
<td>被线程 M 持有，并且正在执行用户代码或者调度器</td>
</tr>
<tr>
<td><code>_Psyscall</code></td>
<td>没有执行用户代码，当前线程陷入系统调用</td>
</tr>
<tr>
<td><code>_Pgcstop</code></td>
<td>被线程 M 持有，当前处理器由于垃圾回收被停止</td>
</tr>
<tr>
<td><code>_Pdead</code></td>
<td>当前处理器已经不被使用</td>
</tr>
</tbody>
</table>
<p>G-M-P模型的思想就是在每个线程中都保存一个协程队列，线程不直接和协程打交道，而是从p中取协程执行，如果p中的协程都被消费完了，p再从全局协程队列获取锁拿取一批协程放入本地队列，如果本地或者全局都没有协程了，则会去看其他线程有没有没执行完的协程，偷几个过来。</p>
<p>p的个数是通过<code>GOMAXPROCS</code>参数来控制的，默认为cpu核心的个数。</p>
<p>任务窃取调度器的缺点：</p>
<ul>
<li>在某些情况下协程不会让出，导致线程饥饿。</li>
<li>在gc时的stw时间太长，会导致程序无法工作。</li>
</ul>
<h3 id="抢占式调度器">抢占式调度器</h3>
<h4 id="基于协作的抢占式调度器">基于协作的抢占式调度器</h4>
<p>编译器编译的时，在调用函数前，插入<code>morestack()</code>函数，在发生函数调用时，可能会执行编译器前插的<code>morestack()</code>函数，这个函数调用的<code>newStack()</code>会检查协程的<code>stackguard0</code>是否为<code>StackPreemt</code>这个数是一个很大的数，所以可以用作判断。如果<code>stackguard0</code>为<code>stackpreemt</code>则会触发抢占，让出当前协程。</p>
<p>这种方式有个缺点，那就是这个是主动行为，如果没发生函数调用的时候，这种检测方式将不适用。</p>
<h4 id="基于信号的抢占式调度">基于信号的抢占式调度</h4>
<ol>
<li>在sighandler中注册<code>SIGURG</code>信号的处理函数。</li>
<li>在gc的时候，gc线程会将<code>_GRunning</code>的g标记成可抢占，并且调用<code>preemptM</code>向线程发送<code>SIGURG</code>信号，然后就会调用schedule进行调度。</li>
</ol>
<h3 id="栈增长">栈增长</h3>
<p>在前面<a href="#%E8%B0%83%E7%94%A8%E6%A0%88">调用栈</a>中说过，go语言的栈帧大小是一次性确定的，就是通过插入栈增长检测代码确定是否需要栈增长。</p>
<p><code>stackguard0</code>：栈的下界</p>
<p>framesize &lt;= _StackSmall时，如果sp指针 &gt; <code>stackguard0</code>，就要进行栈增长。</p>
<p>_StackSmall &lt; framesize &lt;= _StackBig, 超出 <code>stackguard0</code>的部分 &gt; _stacksmall就会进行栈增长。</p>
<p>_StackBig &lt; framesize，也会执行栈增长，此时会将<code>stackguard0</code>设置为<code>stackpreemt</code>。这样执行<code>morestack</code>函数的时候，会根据这个<code>stackguard0</code>是否为<code>stackpreemt</code>来判断当前协程是否需要被抢占。</p>
<h3 id="调度过程部分代码">调度过程（部分代码）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">schedule</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">top</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">preempt</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">checkTimers</span>(<span style="color:#a6e22e">pp</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">inheritTime</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">schedtick</span><span style="color:#f92672">%</span><span style="color:#ae81ff">61</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">runqsize</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">gp</span> = <span style="color:#a6e22e">globrunqget</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>(), <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span> = <span style="color:#a6e22e">runqget</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span> = <span style="color:#a6e22e">findrunnable</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">spinning</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">resetspinning</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>总结一下调度的流程：</p>
<ol>
<li>检查p的timers，看是否有到时间的g能够运行。</li>
<li>寻找可以运行的g。</li>
<li>如果当前的m在自旋，就唤醒</li>
<li>运行g。</li>
<li>执行结束之后，就会调用栈顶的<code>goexit()</code>函数退出协程。</li>
</ol>
<h4 id="怎么去找g呢">怎么去找g呢</h4>
<ol>
<li>为了保证公平，当全局队列有可执行的g时，调度器会在执行<strong>61</strong>次调度之后，去全局队列找一个g来执行。</li>
<li>去当前p的本地队列找可执行的g。</li>
<li>如果还是没有可执行的g时，就会调用<code>findrunable()</code>函数。</li>
</ol>
<p><code>findrunnable()</code>寻找g的步骤：</p>
<ol>
<li>从本地队列找。</li>
<li>去全局队列找。</li>
<li>去其他其他随机的p中偷。</li>
<li>netpoll中找。</li>
</ol>
<h4 id="运行g">运行g</h4>
<p>上面调度函数中调用的<code>execute()</code>函数（节选）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">inheritTime</span> <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">curg</span> = <span style="color:#a6e22e">gp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Grunnable</span>, <span style="color:#a6e22e">_Grunning</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gogo</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sched</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主要是用m执行g，把g的状态从<code>_Grunnable</code>改成<code>_GRunning</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">TEXT</span> <span style="color:#66d9ef">gogo</span><span style="color:#960050;background-color:#1e0010">&lt;&gt;</span>(<span style="color:#66d9ef">SB</span>), <span style="color:#66d9ef">NOSPLIT</span>, <span style="color:#66d9ef">$0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">get_tls</span>(<span style="color:#66d9ef">CX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">DX</span>, <span style="color:#66d9ef">g</span>(<span style="color:#66d9ef">CX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">DX</span>, <span style="color:#66d9ef">R14</span>		<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">set</span> <span style="color:#66d9ef">the</span> <span style="color:#66d9ef">g</span> <span style="color:#66d9ef">register</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">gobuf_sp</span>(<span style="color:#66d9ef">BX</span>), <span style="color:#66d9ef">SP</span>	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">restore</span> <span style="color:#66d9ef">SP</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">gobuf_ret</span>(<span style="color:#66d9ef">BX</span>), <span style="color:#66d9ef">AX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">gobuf_ctxt</span>(<span style="color:#66d9ef">BX</span>), <span style="color:#66d9ef">DX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">gobuf_bp</span>(<span style="color:#66d9ef">BX</span>), <span style="color:#66d9ef">BP</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">gobuf_sp</span>(<span style="color:#66d9ef">BX</span>)	<span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#66d9ef">clear</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">help</span> <span style="color:#66d9ef">garbage</span> <span style="color:#66d9ef">collector</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">gobuf_ret</span>(<span style="color:#66d9ef">BX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">gobuf_ctxt</span>(<span style="color:#66d9ef">BX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">$0</span>, <span style="color:#66d9ef">gobuf_bp</span>(<span style="color:#66d9ef">BX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#66d9ef">gobuf_pc</span>(<span style="color:#66d9ef">BX</span>), <span style="color:#66d9ef">BX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">JMP</span>	<span style="color:#66d9ef">BX</span>
</span></span></code></pre></div><p>值得一提的是，在<code>MOVQ	gobuf_sp(BX), SP</code>这一行恢复的<strong>sp</strong>，就是之前<a href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E5%8D%8F%E7%A8%8B%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88">创建新协程经历了什么</a>中提到的<code>goexit</code>函数，也就是在这里会调用<code>goexit()</code>函数。</p>
<p>执行完成之后，会把g的状态从<code>_GRunning</code>改成<code>_GDead</code>，加入到<code>gfree</code>中，等待下一次协程创建的时候可以复用。</p>
<h3 id="调度时机">调度时机</h3>
<p><a href="https://segmentfault.com/a/1190000040405826">https://segmentfault.com/a/1190000040405826</a></p>
<p><img src="go%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA.png" alt="go调度时机"></p>
<ol>
<li>主动调用<code>gopark()</code>，如time.Sleep()底层调用了<code>gopark</code>。</li>
<li>系统调用完成<code>exitsyscall</code>。</li>
<li>协作式调度（编译器在函数调用前插入<code>morestack()</code>）。</li>
<li>系统监控<code>sysmon</code>。监控线程由<code>main goroutine</code> (<code>runtime.main</code>)创建的，确保<code>timers</code>执行，该m不需要依赖p。</li>
<li>上图还没有的是<strong>异步抢占</strong>：gc线程会向m发送<code>SIGURG</code>信号，通知g让出。</li>
</ol>
<h4 id="gopark">gopark</h4>
<p><code>time.Sleep</code>，是让协程休眠从<code>_Grunning</code>变为<code>_GWaiting</code>加入到p中的timers函数中，然后在调度的时候，会调用<code>checktimers</code>函数，唤醒那些在<code>_GWaiting</code>的g。</p>
<p>万一所有的线程都在忙，无法触发调度，那该怎么唤醒呢？</p>
<p>监控线程会检查这些timer，让到时间的g能够放入等待队列中。</p>
<h4 id="sysmon">sysmon</h4>
<p>由<code>main goroutine</code>创建的系统监控线程，<strong>该m不需要依赖p</strong>，会定时调度，保证timers正常运作。</p>
<p>会调用<code>retake</code>函数进而调用<code>schedule</code>函数。</p>
<p>监控线程的<strong>调度职责</strong>：</p>
<ol>
<li>监控协程运行时间是否过长，如果过长，把stackguard0设置为<code>stackpreemt</code>会调用morestack函数触发调度.</li>
<li>如果p距离上次的系统调用时间过长，则会把p修改成空闲的状态，并且指派一个m给p，让m运行g。</li>
</ol>
<h4 id="系统调用">系统调用</h4>
<p>如果线程上的g陷入了系统调用，则该m也会陷入系统调用而阻塞，此时，会把原来附着的p解绑，并且把p上的m对象解绑，把p的状态改成<code>_Psyscall</code>。等待<strong>监控线程</strong>给这个p做一些操作，如监控p陷入了系统调用时间是否太长，如果太长则会和一个m绑定（无论是从<code>midle</code>还是新建一个m）来运行g。</p>
<p>在结束系统调用的时候，操作系统会调用<code>exitsyscall</code>回调函数</p>
<p>如果系统调用结束的很快，则会判断原来的p是否还在等待（_PSyscall），如果还在等待，则将系统调用返回的m和该p绑定。</p>
<p>如果原来的p不能用了，将g放入<strong>全局</strong>等待队列。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reentersyscall</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span> <span style="color:#66d9ef">uintptr</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard0</span> = <span style="color:#a6e22e">stackPreempt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">_g_</span>, <span style="color:#a6e22e">_Grunning</span>, <span style="color:#a6e22e">_Gsyscall</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sysmonwait</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">systemstack</span>(<span style="color:#a6e22e">entersyscall_sysmon</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录oldp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">oldp</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">pp</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">_Psyscall</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">gcwaiting</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">systemstack</span>(<span style="color:#a6e22e">entersyscall_gcwait</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">exitsyscall0</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Gsyscall</span>, <span style="color:#a6e22e">_Grunnable</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dropg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">schedEnabled</span>(<span style="color:#a6e22e">gp</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">_p_</span> = <span style="color:#a6e22e">pidleget</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">locked</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">globrunqput</span>(<span style="color:#a6e22e">gp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">locked</span> = <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">lockedm</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sysmonwait</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sysmonwait</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">notewakeup</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sysmonnote</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">acquirep</span>(<span style="color:#a6e22e">_p_</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#66d9ef">false</span>) <span style="color:#75715e">// Never returns.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">locked</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Wait until another thread schedules gp and so m again.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// N.B. lockedm must be this M, as this g was running on this M
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// before entersyscall.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">stoplockedm</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#66d9ef">false</span>) <span style="color:#75715e">// Never returns.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stopm</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">schedule</span>() <span style="color:#75715e">// Never returns.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="channel">channel</h2>
<h3 id="数据结构-5">数据结构</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hchan</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">qcount</span>   <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// 存了多少个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">dataqsiz</span> <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// 环形队列的大小（最多存多少个元素）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">buf</span>      <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 缓冲区的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">elemsize</span> <span style="color:#66d9ef">uint16</span> <span style="color:#75715e">// 每个元素的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">closed</span>   <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// 是否close
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">elemtype</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span> <span style="color:#75715e">// channel的元素类型都是一样的，所以需要指明是哪种数据类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">sendx</span>    <span style="color:#66d9ef">uint</span>   <span style="color:#75715e">// 发送的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">recvx</span>    <span style="color:#66d9ef">uint</span>   <span style="color:#75715e">// 接收的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">recvq</span>    <span style="color:#a6e22e">waitq</span>  <span style="color:#75715e">// 接收的g阻塞队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">sendq</span>    <span style="color:#a6e22e">waitq</span>  <span style="color:#75715e">// 发送的g阻塞队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span> <span style="color:#75715e">// 多协程的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>其中waitq中存放了队列的首和尾，为<code>sudog</code>类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">sudog</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>  <span style="color:#75715e">// 协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prev</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 发送的数据在哪
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">acquiretime</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">releasetime</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ticket</span>      <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">isSelect</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// select是否选择了此协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">success</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">parent</span>   <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// semaRoot binary tree
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">waitlink</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// g.waiting list or semaRoot
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">waittail</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// semaRoot
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>        <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span> <span style="color:#75715e">// 等待的channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>channel底层实现的方式为环形数组。</p>
<p>如果接收者阻塞了会把接收者放入recvq</p>
<p>如果发送者阻塞了会把发送者放入sendq</p>
<p>写入数据到channel是调用<code>chansend</code>，从channel读取数据是调用<code>chanrecv</code></p>
<h3 id="发送">发送</h3>
<p>写入数据到channel是调用<code>chansend</code>，下面是该函数的部分。</p>
<p>可以看见，在channel关闭之后，是不让写数据进去的，直接抛出panic。</p>
<ol>
<li>在发送的时候，会从recvq队列（如果这个队列中有，代表该receiver已经阻塞了）中取出一个receiver。</li>
<li>如果没有receiver，就看缓冲区能不能放数据，如果放不了就阻塞sender，把sender放入senq中。阻塞是调用gopark，把g的状态改成_Gwaiting。</li>
<li>如果有receiver，在send的时候把数据直接拷贝到receiver的elem中。</li>
<li>调用goready把receiver的状态改会_GRunnable。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chansend</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">ep</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">block</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">callerpc</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">full</span>(<span style="color:#a6e22e">c</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>		panic(<span style="color:#a6e22e">plainError</span>(<span style="color:#e6db74">&#34;send on closed channel&#34;</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 注意看，这里是recvq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvq</span>.<span style="color:#a6e22e">dequeue</span>(); <span style="color:#a6e22e">sg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) }, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> &lt; <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">qp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chanbuf</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 拷贝数据到缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">qp</span>, <span style="color:#a6e22e">ep</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquireSudog</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t0</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">elem</span> = <span style="color:#a6e22e">ep</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">gp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">waiting</span> = <span style="color:#a6e22e">mysg</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendq</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">mysg</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">chanparkcommit</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>), <span style="color:#a6e22e">waitReasonChanSend</span>, <span style="color:#a6e22e">traceEvGoBlockSend</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">activeStackChans</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">closed</span> <span style="color:#f92672">:=</span> !<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">success</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">c</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">releaseSudog</span>(<span style="color:#a6e22e">mysg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">send</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">sg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>, <span style="color:#a6e22e">ep</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">unlockf</span> <span style="color:#66d9ef">func</span>(), <span style="color:#a6e22e">skip</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">elem</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sendDirect</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">elem</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">g</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">unlockf</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">success</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">releasetime</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#a6e22e">cputicks</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">goready</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">skip</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="接收">接收</h3>
<p>接收函数如下（也是节选）。</p>
<p>可以看见在channel close情况下，如果缓冲区还有数据残留，则消费者可以继续从缓冲区消费，而不会panic。</p>
<ol>
<li>在接收时，会从sendq中获取一个sender（此时一定是_GWaiting）。</li>
<li>如果没获取到sender，就从缓冲区复制到接收对象，如果缓冲区的数据都消费完了，则会阻塞receiver。</li>
<li>如果获取到了sender，如果channel是非缓冲的，直接从sender中获取数据。如果channel是缓冲的，首先从缓冲区拷贝数据到接收对象，然后再从sender复制的数据拷贝到接收对象。调用goready把sender的状态改为_GRunnable.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">ep</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">block</span> <span style="color:#66d9ef">bool</span>) (<span style="color:#a6e22e">selected</span>, <span style="color:#a6e22e">received</span> <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">gopark</span>(<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">waitReasonChanReceiveNilChan</span>, <span style="color:#a6e22e">traceEvGoStop</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">empty</span>(<span style="color:#a6e22e">c</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">closed</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里是sendq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendq</span>.<span style="color:#a6e22e">dequeue</span>(); <span style="color:#a6e22e">sg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">recv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>) }, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">qp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chanbuf</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 从缓冲区拷贝数据到接收对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#a6e22e">qp</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">typedmemclr</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">qp</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">qcount</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">block</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// no sender available: block on this channel.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquireSudog</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">waiting</span> = <span style="color:#a6e22e">mysg</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mysg</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">gp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvq</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">mysg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store8</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">parkingOnChan</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">chanparkcommit</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">lock</span>), <span style="color:#a6e22e">waitReasonChanReceive</span>, <span style="color:#a6e22e">traceEvGoBlockRecv</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">waiting</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">releaseSudog</span>(<span style="color:#a6e22e">mysg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">success</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">recv</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">sg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span>, <span style="color:#a6e22e">ep</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">unlockf</span> <span style="color:#66d9ef">func</span>(), <span style="color:#a6e22e">skip</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// copy data from sender
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">recvDirect</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">sg</span>, <span style="color:#a6e22e">ep</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">qp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">chanbuf</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ep</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">ep</span>, <span style="color:#a6e22e">qp</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">elemtype</span>, <span style="color:#a6e22e">qp</span>, <span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">elem</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">dataqsiz</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">sendx</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">recvx</span> <span style="color:#75715e">// c.sendx = (c.sendx+1) % c.dataqsiz
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">elem</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">g</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">unlockf</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">success</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">releasetime</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sg</span>.<span style="color:#a6e22e">releasetime</span> = <span style="color:#a6e22e">cputicks</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">goready</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">skip</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="select">select</h2>
<ul>
<li>select能够在channel上进行非阻塞的收发操作。</li>
<li>select在遇到多个channel的时候，会随机选择一个channel执行。</li>
</ul>
<p>实现原理：</p>
<p>go会把select编译成</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">selectgo</span>(<span style="color:#a6e22e">cas0</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">scase</span>, <span style="color:#a6e22e">order0</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint16</span>, <span style="color:#a6e22e">pc0</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">nsends</span>, <span style="color:#a6e22e">nrecvs</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">block</span> <span style="color:#66d9ef">bool</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">bool</span>) {}
</span></span></code></pre></div><p>参数</p>
<ol>
<li>cas0表示所有的分支，send在前，recv在后。</li>
<li>order0被分为两个数组，第一个数组表示轮询的顺序，第二个数组表示channel加锁的顺序。</li>
<li>nsends和nrecvs表示send和recv分支的个数分别由多少个。</li>
<li>block表示是否有default分支，如果有default分支则为false。</li>
</ol>
<p>返回值</p>
<ol>
<li>第一个返回值表示哪个分支被执行了，default为-1。</li>
<li>第二个表示channel是否有返回值。</li>
</ol>
<h3 id="工作原理">工作原理</h3>
<p>select会对所有注册的channel轮询（乱序），检查channel的等待队列和缓冲区，如果缓冲区有数据或者能发送数据，则接收数据或者发送数据。假如都不能操作，则把当前的用户协程放入不能操作的channel的等待队列（sendq/recvq）中，等待能够唤醒则把当前g唤醒，并且从channel的等待队列中移除。</p>
<h2 id="锁">锁</h2>
<h3 id="互斥锁">互斥锁</h3>
<h4 id="数据结构-6">数据结构</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mutex</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">state</span> <span style="color:#66d9ef">int32</span> <span style="color:#75715e">// 加锁和解锁操作的字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sema</span>  <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// 信号量，主要用作等待队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="两种模式">两种模式</h3>
<h4 id="正常模式">正常模式</h4>
<p>尝试加锁的协程会自旋获取锁，如果获取不到就排队等待。</p>
<p>但是被唤醒的协程排队结束之后，不会直接获取锁，而是要和那些正在自旋的协程竞争。如果刚唤醒的协程竞争不过，则会把他放到队列的头部。</p>
<p>当一个协程本次加锁的时间超过了1ms之后，锁的状态会被改成饥饿模式。</p>
<h4 id="饥饿模式">饥饿模式</h4>
<p>所有要获取锁的协程都直接去排队等待，不自旋。</p>
<p>协程会在以下情况将饥饿模式改为正常模式：</p>
<ul>
<li>本协程等待时间小于1ms</li>
<li>锁的等待队列空了</li>
</ul>
<h1 id="gc">GC</h1>
<h2 id="内存分布">内存分布</h2>
<p><img src=".%5C%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="image-20220728215241574"></p>
<p>指令存在代码段，静态区域和全局变量存在数据段，函数的局部变量、返回值、参数放在栈上，如果不能在编译阶段确定数据对象的大小或者变量的生命周期超出当前所在函数，则会分配在堆上。</p>
<p>栈上的空间不用gc，当函数调用结束就会自动释放，而堆上的空间，如果不能及时释放就会导致内存泄漏。</p>
<h2 id="几种垃圾回收算法">几种垃圾回收算法</h2>
<h3 id="标记清除算法">标记清除算法</h3>
<p>程序用的到的数据，一定是由栈和数据段作为根节点追踪得到的数据，如果从根节点不能追踪到的数据，一定是垃圾数据，就要被回收了，所以把能够追踪到的数据都进行标记，把那些没有标记的数据给清除了，这就是标记清除算法的思想。</p>
<h4 id="三色标记">三色标记</h4>
<p>白色对象：目标的垃圾，需要回收。</p>
<p>灰色对象：活跃的对象，可能指向白色的对象，需要进一步扫描这些对象的子对象。</p>
<p>黑色对象：活跃的对象，这个对象和他直接引用的对象都被访问过。黑色所指向的对象都是灰色的，gc线程不会再访问这个对象。</p>
<p>最开始的时候，所有的数据都是白色。</p>
<p><img src=".%5C%E4%B8%89%E8%89%B21.png" alt="三色1"></p>
<p>把root节点都标记成灰色，灰色表示基于当前节点的追踪还没有完成。</p>
<p><img src=".%5C%E4%B8%89%E8%89%B22.png" alt="三色1"></p>
<p>如果基于某个节点的追踪完成之后，会把该节点标记为黑色，表示数据存活并且不需要再基于这个节点进行跟踪了。</p>
<p>简单概括一下步骤：</p>
<ol>
<li>在最开始的时候，所有对象都是白色的，把根节点（栈、数据段）都标记为灰色的。</li>
<li>从灰色对象的集合中选择一个对象标记成黑色的。</li>
<li>把黑色对象指向的对象标记成灰色的。</li>
<li>重复上面的步骤，直到没有灰色的对象。此刻堆中的对象只会剩下白色的，就是目标垃圾回收对象。</li>
</ol>
<p><img src=".%5C%E4%B8%89%E8%89%B23.png" alt="tri-color-mark-sweep"></p>
<h3 id="复制压缩算法">复制压缩算法</h3>
<p>把内存中造成的碎片向一边移动，这样就会腾出一块连续的空间。</p>
<p><img src=".%5C%E5%A4%8D%E5%88%B6%E7%A7%BB%E5%8A%A8%E6%B8%85%E7%90%86.png" alt="复制移动清理"></p>
<h3 id="分代回收算法jvm-serial收集器用的算法">分代回收算法(JVM Serial收集器用的算法)</h3>
<p>把内存分为几个区域，保存不同年龄的对象，分为新生代、老年代、永久代。</p>
<p>新生代分为eden区，survivor区。在gc的时候，扫描eden space和survior（s0或者s1)，将gc后的对象移动到survivor中空闲的区域（s0或者s1)，如果有一个s区满了或者一些对象达到了年龄的阈值，就将这一部分的对象移动到老年代。而如果老年代的内存满了也会采用复制压缩算法去gc。</p>
<p>下面的永久代，已经在jdk8中移除，在早期版本中是存放在方法区中。</p>
<p><img src=".%5C%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6.png" alt=""></p>
<h3 id="引用计数法">引用计数法</h3>
<p>在程序运行时，gc线程会给每个对象维护一个引用计数器，如果引用到0了，就说明可以进行回收。但是会有一个问题，如果两个对象互相引用，则引用计数器不可能会达到0.</p>
<p>上面说的都是在stop the world 的情况下的gc算法，实际上用户线程不能忍受长时间的stw。</p>
<h2 id="垃圾回收的stw优化">垃圾回收的stw优化</h2>
<h3 id="增量stw">增量stw</h3>
<p>避免一次stw给用户线程给停了，那就分多次，每次只暂停一小段时间。</p>
<p><img src="%E5%A2%9E%E9%87%8Fstw.png" alt=""></p>
<p>但是这样会有一个问题，如果采用的是标记清除算法，可能前脚gc线程判定的一个对象是黑色的，后脚用户线程就更改了该对象和原本待清除的对象（此时不该清除）的关联关系，而黑色对象不会再被访问，所以不能改变白色对象的颜色，造成错误的清理。即指针没有指向特定类型的对象，会造成悬挂指针问题，如下图</p>
<p><img src=".%5C%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%9A%84%E5%BC%8A%E7%AB%AF.png" alt=""></p>
<p>所以会引入屏障技术。</p>
<h4 id="两个不变式">两个不变式</h4>
<p>强三色不变式：黑色对象不会指向白色对象，只会指向黑色或者灰色对象。</p>
<p>弱三色不变式：黑色所指向的白色对象，必须包含一个灰色对象指向该白色对象。</p>
<h4 id="满足两个不变式的实现">满足两个不变式的实现</h4>
<p><del>写屏障：在屏障之前，对共享变量的改动都会同步到主存中。</del></p>
<p><del>读屏障：在屏障之后，从内存中读取的共享变量都是最新的数据。</del></p>
<h5 id="插入写屏障">插入写屏障</h5>
<p>插入写屏障：在a引用b时，把b标记成灰色。满足强三色不变式。</p>
<p>举个例子：</p>
<p>假设a是栈上的root所指向的对象。</p>
<p><img src="%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C.png" alt=""></p>
<p>在上图中，第二个图用户程序突然改变了a的引用关系，但是此时由于插入写屏障，所以c对象的颜色被调整为灰色。</p>
<p>但是如果a指针指向了c，则b应该要清理才能节约内存，但是b为黑色，不能清理，所以需要<strong>对栈上的对象stw</strong>从栈开始从新扫描把b给清理掉。</p>
<h5 id="删除写屏障">删除写屏障</h5>
<p>被删除引用对象，如果自身是白色或者灰色，则置为灰色。满足了弱三色不变式。</p>
<p>说人话就是要删除灰色到白色引用时，把被删除的引用对象置为灰色，这样就不会有黑色指向白色的情况了。</p>
<p><img src="%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C.png" alt=""></p>
<p>在第三个图中，触发了删除写屏障，c被置为了灰色，但是b也没有删除。</p>
<h5 id="混合写屏障">混合写屏障</h5>
<ol>
<li>gc开始时，栈上的所有对象可达的所有对象都标记为黑色，期间在栈上新增的对象也都标记成黑色。</li>
<li>gc时被删除的对象标记为灰色。</li>
<li>gc时被添加的对象标记为灰色。</li>
</ol>
<h1 id="内存管理">内存管理</h1>
<h2 id="逃逸分析">逃逸分析</h2>
<p>会分析函数内变量生命周期是否超出了函数，如果超出则放入堆。</p>
<p>多级间接赋值会导致逃逸：如data.Key = value，key为引用类型，则value一定会逃逸。</p>
<h2 id="一些概念">一些概念</h2>
<p>ref: <a href="https://learnku.com/articles/68142">https://learnku.com/articles/68142</a></p>
<p>page: 和操作系统打交道的最小内存申请单位，大小为8kb.</p>
<p>mspan: 由一个或者多个连续的page组成，内存管理的基本单元。</p>
<p>arena: 把堆内存划分成一个个arena，arena中管理着8192个mspan。</p>
<p>object：如果以page作为内存分配的单位，会造成内碎片和外碎片的问题，那就采用对对象分级的方法，给不同大小的对象分配不同的块。</p>
<p>对象的大小：</p>
<p>微对象：[0, 16B)</p>
<p>小对象：[16B, 32kb)</p>
<p>大对象：[32kb, +inf)</p>
<p>sizeclass: 表示一块内存的规格，根据object的大小来分级，如1b - 8b大小之间的对象的sizeclass为1，8-16b之间为2，如此推断。go语言提供了<strong>67</strong>种规格的内存块。</p>
<p>spanclass：因为span是内存管理的基本单位，内存管理就包括gc等，在gc时可以借助spanclass来看该span中的object是否需要扫描（如果是指针类型则需要扫描）。其中，spanClass和sizeClass的关系是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeSpanClass</span>(<span style="color:#a6e22e">sizeclass</span> <span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">noscan</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">spanClass</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">spanClass</span>(<span style="color:#a6e22e">sizeclass</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>) | <span style="color:#a6e22e">spanClass</span>(<span style="color:#a6e22e">bool2int</span>(<span style="color:#a6e22e">noscan</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//假如sizeClass = 1 noscan = true =&gt; spanClass = 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//假如sizeClass = 1 noscan = false =&gt; spanClass = 2
</span></span></span></code></pre></div><h2 id="内存模型">内存模型</h2>
<p><img src="%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h3 id="mcache">mcache</h3>
<p>每一个<code>p</code>都会被分配一个<code>mcache</code>，用于<strong>微对象和小对象</strong>（对象大小&lt;32kb）的分配，因为每个p在同一时间只能运行一个m，所以不存在线程竞争的问题，所以m在向mcache申请内存的时候不会进行加锁操作。</p>
<p>mcache中会管理着136(68 * 2，因为68个sizeClass * 是否需要gc)个mspan。并且根据spanClass进行对象的分级。</p>
<p>对于spanClass为0或者为1（sizeClass == 0)的对象，会返回一个<code>zerobase</code>（上面在结构体提到过，不占内存）。</p>
<p>但是要注意的是，如果是微对象，会在tiny内存上去获取span。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mcache</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nextSample</span> <span style="color:#66d9ef">uintptr</span> 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">scanAlloc</span>  <span style="color:#66d9ef">uintptr</span> 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tiny</span>       <span style="color:#66d9ef">uintptr</span>  <span style="color:#75715e">// tiny内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tinyoffset</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tinyAllocs</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">alloc</span> [<span style="color:#a6e22e">numSpanClasses</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> <span style="color:#75715e">// numSpanClasses = 68 &lt;&lt; 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stackcache</span> [<span style="color:#a6e22e">_NumStackOrders</span>]<span style="color:#a6e22e">stackfreelist</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">flushGen</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="mcentral">mcentral</h3>
<p>如果mcache中的某个spanClass的span被填完了，则mcache会向<strong>mheap</strong>中对应的spanClass的<strong>mcentral</strong>申请span。</p>
<p>mcentral维护两个<code>spanset</code>，一个维护全部空闲的Span集合；一个维护存在非空闲的Span集合；mcache向mcentral申请span时，<strong>需要加锁</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mcentral</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spanclass</span> <span style="color:#a6e22e">spanClass</span> <span style="color:#75715e">// spanClass级别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">partial</span> [<span style="color:#ae81ff">2</span>]<span style="color:#a6e22e">spanSet</span> <span style="color:#75715e">// 全部空闲的span集合，分为两种，清理和未清理的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">full</span>    [<span style="color:#ae81ff">2</span>]<span style="color:#a6e22e">spanSet</span> <span style="color:#75715e">// 不包含空闲对象的span集合，分为两种，清理和未清理的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>mcache向mcentral申请内存的过程：</p>
<ol>
<li>先向空闲的，清理的partial申请mspan，如果没有就从未清理的，空闲的partial申请mspan。</li>
<li>如果上面的partial中找不到，就去未清理的有空闲的full中申请，如果申请到了mspan，则清理这个mspan。前面两个步骤中，如果申请到了，将span从对应的队列中pop，返回。</li>
<li>如果上面的都没找到空闲mspan，触发扩容从堆中申请新的内存，这个时候会从heaparena中申请。</li>
</ol>
<p>下面是上面的步骤的源码（节选）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mcentral</span>) <span style="color:#a6e22e">cacheSpan</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mheap_</span>.<span style="color:#a6e22e">sweepgen</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">spanBudget</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">partialSwept</span>(<span style="color:#a6e22e">sg</span>).<span style="color:#a6e22e">pop</span>(); <span style="color:#a6e22e">s</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">havespan</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// partial
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">spanBudget</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">spanBudget</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">partialUnswept</span>(<span style="color:#a6e22e">sg</span>).<span style="color:#a6e22e">pop</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweep</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">havespan</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// full队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">spanBudget</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">spanBudget</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">fullUnswept</span>(<span style="color:#a6e22e">sg</span>).<span style="color:#a6e22e">pop</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Cas</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweepgen</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">sg</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">sweep</span>(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">freeIndex</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nextFreeIndex</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">freeIndex</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">nelems</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> = <span style="color:#a6e22e">freeIndex</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">havespan</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">fullSwept</span>(<span style="color:#a6e22e">sg</span>).<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 上面两个阶段都没获取到空闲mspan
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">grow</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">havespan</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">freeByteBase</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> <span style="color:#f92672">&amp;^</span> (<span style="color:#ae81ff">64</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">whichByte</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">freeByteBase</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">refillAllocCache</span>(<span style="color:#a6e22e">whichByte</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">allocCache</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">freeindex</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="mheap">mheap</h3>
<p>数据结构（节选）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">mheap</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lock</span>  <span style="color:#a6e22e">mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pages</span> <span style="color:#a6e22e">pageAlloc</span> <span style="color:#75715e">// page allocation data structure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sweepgen</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// sweep generation, see comment in mspan; written during STW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">allspans</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">mspan</span> <span style="color:#75715e">// all spans out there
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pagesInUse</span>         <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Uint64</span> <span style="color:#75715e">// pages of spans in stats mSpanInUse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pagesSwept</span>         <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Uint64</span> <span style="color:#75715e">// pages swept this cycle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">arenas</span> [<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">arenaL1Bits</span>]<span style="color:#f92672">*</span>[<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">arenaL2Bits</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">heapArena</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// numSpanClasses = 68 &lt;&lt; 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">central</span> [<span style="color:#a6e22e">numSpanClasses</span>]<span style="color:#66d9ef">struct</span> {  
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mcentral</span> <span style="color:#a6e22e">mcentral</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pad</span>      [<span style="color:#a6e22e">cpu</span>.<span style="color:#a6e22e">CacheLinePadSize</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">mcentral</span>{})<span style="color:#f92672">%</span><span style="color:#a6e22e">cpu</span>.<span style="color:#a6e22e">CacheLinePadSize</span>]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="内存分配">内存分配</h2>
<p>总结一句话，微小对象(<strong>不可以是指针类型</strong>)[0, 16b) ，依次在mcache上的tiny指针、span数组、mcentral中的span数组空间申请，如果tiny对象放满了，或者后来的对象没位置放，就会从mcache中的span数组申请一个16b大小的内存空间，如果新的内存空间比原来剩下的那个tiny内存空间还大，就会用新的替换原来的。（有一个问题，原来的去哪了？）</p>
<p>小对象[16b, 32k) 在mcache的span数组申请，如果mcache中对应spanClass的槽位没了（相同spanclass的span太多了，被申请完了），mcache向mheap中的mcentral申请对应spanClass的span。</p>
<p>大对象直接通过mheap申请heaparena中的span，如果arena中没有，直接申请操作系统中的内存。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://kyriexu11.github.io/" >
    &copy;  Secret Room of KyrieXu11 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
